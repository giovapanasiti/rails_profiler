This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  controllers/
    rails_profiler/
      application_controller.rb
      dashboard_controller.rb
  models/
    rails_profiler/
      profile.rb
  views/
    layouts/
      rails_profiler/
        application.html.erb
    rails_profiler/
      dashboard/
        endpoints.html.erb
        hotspots.html.erb
        index.html.erb
        profiles.html.erb
        show.html.erb
        slowest_queries.html.erb
        trends.html.erb
config/
  routes.rb
db/
  migrate/
    20250519000000_create_rails_profiler_profiles.rb
lib/
  rails_profiler/
    code_profiler.rb
    configuration.rb
    engine.rb
    middleware.rb
    profiler.rb
    query_tracker.rb
    storage.rb
    version.rb
  tasks/
    rails_profiler_tasks.rake
  rails_profiler.rb
rails_profiler.gemspec
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/controllers/rails_profiler/application_controller.rb">
module RailsProfiler
  class ApplicationController < ActionController::Base
    protect_from_forgery with: :exception
    before_action :authenticate_user!

    private

    def authenticate_user!
      authenticate_or_request_with_http_basic do |username, password|
        username == RailsProfiler.config.dashboard_username &&
        password == RailsProfiler.config.dashboard_password
      end
    end
  end
end
</file>

<file path="app/models/rails_profiler/profile.rb">
module RailsProfiler
  class Profile < ActiveRecord::Base
    self.table_name = 'rails_profiler_profiles'
    
    validates :request_id, presence: true, uniqueness: true
  end
end
</file>

<file path="app/views/rails_profiler/dashboard/endpoints.html.erb">
<div class="endpoints-page">
  <div class="dashboard-header">
    <h1>Endpoints</h1>
  </div>

  <% if @selected_endpoint %>
    <div class="endpoint-details">
      <div class="back-button">
        <a href="<%= rails_profiler.endpoints_path %>" class="btn btn-sm btn-outline-secondary">
          <i class="fas fa-arrow-left"></i> Back to all endpoints
        </a>
      </div>
      
      <h2><%= @selected_endpoint %></h2>
      
      <% if @endpoint_profiles.present? %>
        <div class="endpoint-stats">
          <div class="stat-card">
            <h3>Requests</h3>
            <div class="stat-value"><%= @endpoint_profiles.size %></div>
          </div>
          <div class="stat-card">
            <h3>Avg Duration</h3>
            <div class="stat-value">
              <%= (@endpoint_profiles.sum { |p| p[:duration] } / @endpoint_profiles.size).round(2) %> ms
            </div>
          </div>
          <div class="stat-card">
            <h3>Slowest</h3>
            <div class="stat-value">
              <%= @endpoint_profiles.map { |p| p[:duration] }.max.round(2) %> ms
            </div>
          </div>
          <div class="stat-card">
            <h3>Success Rate</h3>
            <div class="stat-value">
              <%= ((@endpoint_profiles.count { |p| p[:status].to_i < 400 }.to_f / @endpoint_profiles.size) * 100).round(1) %>%
            </div>
          </div>
        </div>
        
        <h3>Request Traces</h3>
        <div class="profiles-table">
          <table class="table">
            <thead>
              <tr>
                <th>Duration</th>
                <th>DB Time</th>
                <th>View Time</th>
                <th>Ruby Time</th>
                <th>Status</th>
                <th>Time</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              <% @endpoint_profiles.each do |profile| %>
                <tr>
                  <td>
                    <span class="duration <%= profile[:duration] > 1000 ? 'slow' : (profile[:duration] > 500 ? 'medium' : 'fast') %>">
                      <%= profile[:duration].round(2) %> ms
                    </span>
                    
                    <div class="mini-timeline">
                      <div class="segment db-segment" style="width: <%= ((profile[:db_time] / profile[:duration]) * 100).round(1) %>%"></div>
                      <div class="segment view-segment" style="width: <%= ((profile[:view_time] / profile[:duration]) * 100).round(1) %>%"></div>
                      <div class="segment ruby-segment" style="width: <%= ((profile[:ruby_time] / profile[:duration]) * 100).round(1) %>%"></div>
                    </div>
                  </td>
                  <td><%= profile[:db_time].round(2) %> ms</td>
                  <td><%= profile[:view_time].round(2) %> ms</td>
                  <td><%= profile[:ruby_time].round(2) %> ms</td>
                  <td>
                    <span class="status-badge status-<%= profile[:status].to_s[0] %>00">
                      <%= profile[:status] %>
                    </span>
                  </td>
                  <td><%= profile[:started_at].is_a?(String) ? profile[:started_at] : profile[:started_at].strftime("%H:%M:%S") %></td>
                  <td>
                    <%= link_to "View", rails_profiler.profile_path(profile[:request_id]), class: "btn btn-sm btn-primary" %>
                  </td>
                </tr>
              <% end %>
            </tbody>
          </table>
        </div>
      <% else %>
        <div class="no-data">
          <p>No profiles found for this endpoint.</p>
        </div>
      <% end %>
    </div>
  <% else %>
    <div class="endpoints-list">
      <% @endpoints.each do |endpoint| %>
        <div class="endpoint-card">
          <div class="endpoint-header">
            <h3 class="endpoint-name">
              <a href="<%= rails_profiler.endpoints_path(endpoint: endpoint[:name]) %>">
                <%= endpoint[:name] %>
              </a>
            </h3>
            <div class="endpoint-meta">
              <span class="endpoint-count"><%= endpoint[:count] %> requests</span>
              <span class="endpoint-time"><%= endpoint[:avg_duration].round(2) %> ms avg</span>
            </div>
          </div>
          
          <div class="endpoint-timeline">
            <% endpoint[:segments].each do |segment| %>
              <div class="segment" 
                   style="width: <%= segment[:percentage].round(1) %>%; background-color: <%= segment[:color] %>;"
                   title="<%= segment[:name] %>: <%= segment[:percentage].round(1) %>%"></div>
            <% end %>
          </div>
          
          <div class="endpoint-breakdown">
            <div class="breakdown-item">
              <span class="breakdown-label">Database</span>
              <span class="breakdown-value"><%= endpoint[:avg_db_time].round(1) %> ms</span>
            </div>
            <div class="breakdown-item">
              <span class="breakdown-label">View</span>
              <span class="breakdown-value"><%= endpoint[:avg_view_time].round(1) %> ms</span>
            </div>
            <div class="breakdown-item">
              <span class="breakdown-label">Ruby</span>
              <span class="breakdown-value"><%= endpoint[:avg_ruby_time].round(1) %> ms</span>
            </div>
          </div>
        </div>
      <% end %>
    </div>
  <% end %>
</div>
</file>

<file path="app/views/rails_profiler/dashboard/hotspots.html.erb">
<div class="hotspots-page">
  <div class="dashboard-header">
    <h1>Code Hotspots</h1>
    <div class="dashboard-actions">
      <a href="<%= rails_profiler.root_path %>" class="btn btn-outline-primary">
        <i class="fas fa-arrow-left"></i> Back to Dashboard
      </a>
    </div>
  </div>

  <div class="hotspots-layout">
    <!-- Controller Hotspots -->
    <div class="hotspot-section">
      <div class="section-header">
        <h2>Controller Hotspots</h2>
        <div class="section-info">
          <i class="fas fa-info-circle"></i>
          <div class="tooltip">Controllers that spend the most time processing requests.</div>
        </div>
      </div>
      
      <div class="hotspot-cards">
        <% @hotspots[:controllers].each do |controller| %>
          <div class="hotspot-card">
            <div class="hotspot-header">
              <h3 class="hotspot-name"><%= controller[:name] %></h3>
              <div class="hotspot-value"><%= controller[:value].round(2) %> ms</div>
            </div>
            
            <div class="hotspot-progress">
              <div class="progress-bar" style="width: <%= (controller[:value] / @max_controller_time) * 100 %>%"></div>
            </div>
            
            <div class="hotspot-details">
              <% if controller[:data][:actions].present? %>
                <h4>Top Actions</h4>
                <ul class="action-list">
                  <% controller[:data][:actions].to_a.sort_by { |_, v| -v[:total_time] }.take(3).each do |action, data| %>
                    <li>
                      <span class="action-name"><%= action %>:</span>
                      <span class="action-time"><%= data[:total_time].round(2) %> ms</span>
                    </li>
                  <% end %>
                </ul>
              <% end %>
            </div>
          </div>
        <% end %>
      </div>
    </div>
    
    <!-- Method Hotspots -->
    <div class="hotspot-section">
      <div class="section-header">
        <h2>Method Hotspots</h2>
        <div class="section-info">
          <i class="fas fa-info-circle"></i>
          <div class="tooltip">Methods that spend the most exclusive time (time in the method itself, not in called methods).</div>
        </div>
      </div>
      
      <div class="hotspot-cards method-cards">
        <% @hotspots[:methods].each do |method| %>
          <div class="hotspot-card">
            <div class="hotspot-header">
              <h3 class="hotspot-name"><%= method[:name] %></h3>
              <div class="hotspot-value"><%= method[:value].round(2) %> ms</div>
            </div>
            
            <div class="hotspot-progress">
              <div class="progress-bar" style="width: <%= (method[:value] / @max_method_time) * 100 %>%"></div>
            </div>
            
            <div class="hotspot-details">
              <div class="method-stats">
                <div class="stat">
                  <span class="stat-label">Calls:</span>
                  <span class="stat-value"><%= method[:data][:count] %></span>
                </div>
                <div class="stat">
                  <span class="stat-label">Avg time:</span>
                  <span class="stat-value"><%= (method[:value] / method[:data][:count]).round(2) %> ms</span>
                </div>
                <div class="stat">
                  <span class="stat-label">Total time:</span>
                  <span class="stat-value"><%= method[:data][:total_time].round(2) %> ms</span>
                </div>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    </div>
    
    <!-- Model & View Hotspots -->
    <div class="hotspot-row">
      <!-- Model Hotspots -->
      <div class="hotspot-section">
        <div class="section-header">
          <h2>Model Hotspots</h2>
          <div class="section-info">
            <i class="fas fa-info-circle"></i>
            <div class="tooltip">Models that generate the slowest database queries.</div>
          </div>
        </div>
        
        <div class="hotspot-list">
          <% if @hotspots[:models].empty? %>
            <div class="no-data">No model data available</div>
          <% else %>
            <table class="hotspot-table">
              <thead>
                <tr>
                  <th>Model</th>
                  <th>Query Count</th>
                  <th>Total Time</th>
                  <th>Avg Time</th>
                </tr>
              </thead>
              <tbody>
                <% @hotspots[:models].each do |model| %>
                  <tr>
                    <td class="model-name"><%= model[:name] %></td>
                    <td><%= model[:data][:count] %></td>
                    <td><%= model[:value].round(2) %> ms</td>
                    <td><%= (model[:value] / model[:data][:count]).round(2) %> ms</td>
                  </tr>
                <% end %>
              </tbody>
            </table>
          <% end %>
        </div>
      </div>
      
      <!-- View Hotspots -->
      <div class="hotspot-section">
        <div class="section-header">
          <h2>View Hotspots</h2>
          <div class="section-info">
            <i class="fas fa-info-circle"></i>
            <div class="tooltip">Templates and partials that take the longest to render.</div>
          </div>
        </div>
        
        <div class="hotspot-list">
          <% if @hotspots[:views].empty? %>
            <div class="no-data">No view data available</div>
          <% else %>
            <table class="hotspot-table">
              <thead>
                <tr>
                  <th>Template</th>
                  <th>Render Count</th>
                  <th>Total Time</th>
                  <th>Avg Time</th>
                </tr>
              </thead>
              <tbody>
                <% @hotspots[:views].each do |view| %>
                  <tr>
                    <td class="view-name"><%= view[:name] %></td>
                    <td><%= view[:data][:count] %></td>
                    <td><%= view[:value].round(2) %> ms</td>
                    <td><%= (view[:value] / view[:data][:count]).round(2) %> ms</td>
                  </tr>
                <% end %>
              </tbody>
            </table>
          <% end %>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .hotspots-page {
    max-width: 1400px;
    margin: 0 auto;
    padding: 1rem;
    background-color: <%= RailsProfiler.config.color_scheme[:background] %>;
  }
  
  .dashboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
  }
  
  .dashboard-header h1 {
    color: <%= RailsProfiler.config.color_scheme[:primary] %>;
    font-weight: bold;
    margin: 0;
  }
  
  .hotspots-layout {
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }
  
  .hotspot-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
  }
  
  .hotspot-section {
    background-color: <%= RailsProfiler.config.color_scheme[:card] %>;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    padding: 1.5rem;
  }
  
  .section-header {
    display: flex;
    align-items: center;
    margin-bottom: 1.5rem;
    position: relative;
  }
  
  .section-header h2 {
    font-size: 1.25rem;
    font-weight: 600;
    margin: 0;
    color: <%= RailsProfiler.config.color_scheme[:text] %>;
  }
  
  .section-info {
    margin-left: 0.75rem;
    position: relative;
    color: <%= RailsProfiler.config.color_scheme[:muted] %>;
  }
  
  .section-info .tooltip {
    position: absolute;
    background-color: <%= RailsProfiler.config.color_scheme[:text] %>;
    color: white;
    padding: 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    width: 200px;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    z-index: 10;
  }
  
  .section-info:hover .tooltip {
    display: block;
  }
  
  .hotspot-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1rem;
  }
  
  .method-cards {
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  }
  
  .hotspot-card {
    background-color: <%= RailsProfiler.config.color_scheme[:card] %>;
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 6px;
    padding: 1rem;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  
  .hotspot-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
  
  .hotspot-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 0.5rem;
  }
  
  .hotspot-name {
    font-size: 0.975rem;
    font-weight: 600;
    margin: 0;
    color: <%= RailsProfiler.config.color_scheme[:text] %>;
    word-break: break-word;
  }
  
  .hotspot-value {
    font-size: 0.875rem;
    font-weight: bold;
    color: <%= RailsProfiler.config.color_scheme[:primary] %>;
    white-space: nowrap;
    margin-left: 0.5rem;
  }
  
  .hotspot-progress {
    height: 6px;
    background-color: #E9ECEF;
    border-radius: 3px;
    margin-bottom: 1rem;
    overflow: hidden;
  }
  
  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, <%= RailsProfiler.config.color_scheme[:primary] %>, <%= RailsProfiler.config.color_scheme[:secondary] %>);
    border-radius: 3px;
  }
  
  .hotspot-details {
    font-size: 0.875rem;
  }
  
  .action-list {
    padding-left: 0;
    list-style-type: none;
    margin: 0.5rem 0 0 0;
  }
  
  .action-list li {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.25rem;
  }
  
  .action-name {
    color: <%= RailsProfiler.config.color_scheme[:text] %>;
  }
  
  .action-time {
    color: <%= RailsProfiler.config.color_scheme[:secondary] %>;
    font-weight: 500;
  }
  
  .method-stats {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem 1rem;
  }
  
  .stat {
    display: flex;
    gap: 0.25rem;
  }
  
  .stat-label {
    color: <%= RailsProfiler.config.color_scheme[:muted] %>;
  }
  
  .stat-value {
    color: <%= RailsProfiler.config.color_scheme[:text] %>;
    font-weight: 500;
  }
  
  .hotspot-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .hotspot-table th, .hotspot-table td {
    text-align: left;
    padding: 0.5rem;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    font-size: 0.875rem;
  }
  
  .hotspot-table th {
    color: <%= RailsProfiler.config.color_scheme[:muted] %>;
    font-weight: normal;
  }
  
  .model-name, .view-name {
    font-weight: 500;
    color: <%= RailsProfiler.config.color_scheme[:text] %>;
  }
  
  .no-data {
    color: <%= RailsProfiler.config.color_scheme[:muted] %>;
    text-align: center;
    padding: 2rem 0;
  }

  /* Responsive adjustments */
  @media (max-width: 992px) {
    .hotspot-row {
      grid-template-columns: 1fr;
    }
  }
</style>
</file>

<file path="app/views/rails_profiler/dashboard/trends.html.erb">
<div class="trends-page">
  <div class="dashboard-header">
    <h1>Performance Trends</h1>
    <div class="dashboard-actions">
      <div class="btn-group" role="group">
        <a href="<%= rails_profiler.trends_path(days: 1) %>" class="btn <%= params[:days] == '1' ? 'btn-primary' : 'btn-outline-primary' %>">24 Hours</a>
        <a href="<%= rails_profiler.trends_path(days: 7) %>" class="btn <%= params[:days].blank? || params[:days] == '7' ? 'btn-primary' : 'btn-outline-primary' %>">7 Days</a>
        <a href="<%= rails_profiler.trends_path(days: 30) %>" class="btn <%= params[:days] == '30' ? 'btn-primary' : 'btn-outline-primary' %>">30 Days</a>
      </div>
    </div>
  </div>

  <div class="trends-container">
    <div class="chart-section">
      <h3>Request Volume</h3>
      <div class="chart-container">
        <canvas id="requestVolumeChart"></canvas>
      </div>
    </div>
    
    <div class="chart-section">
      <h3>Response Time</h3>
      <div class="chart-container">
        <canvas id="responseTimeChart"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- Include Chart.js library -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Prepare data for charts
    const trendsData = <%= raw @trends_data.to_json %>;
    
    // Format dates and extract data points
    const labels = trendsData.map(d => new Date(d.timestamp).toLocaleString());
    const requestCounts = trendsData.map(d => d.count);
    const responseTimes = trendsData.map(d => d.avg_duration);
    
    // Create request volume chart
    const requestCtx = document.getElementById('requestVolumeChart').getContext('2d');
    new Chart(requestCtx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: 'Request Count',
          data: requestCounts,
          backgroundColor: 'rgba(54, 162, 235, 0.2)',
          borderColor: 'rgba(54, 162, 235, 1)',
          borderWidth: 2,
          pointRadius: 3,
          fill: true,
          tension: 0.3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: {
              maxRotation: 45,
              minRotation: 45
            }
          },
          y: {
            beginAtZero: true
          }
        },
        plugins: {
          legend: {
            position: 'top',
          },
          tooltip: {
            callbacks: {
              title: function(tooltipItems) {
                const date = new Date(trendsData[tooltipItems[0].dataIndex].timestamp);
                return date.toLocaleString();
              }
            }
          }
        }
      }
    });
    
    // Create response time chart
    const responseCtx = document.getElementById('responseTimeChart').getContext('2d');
    new Chart(responseCtx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: 'Average Response Time (ms)',
          data: responseTimes,
          backgroundColor: 'rgba(255, 159, 64, 0.2)',
          borderColor: 'rgba(255, 159, 64, 1)',
          borderWidth: 2,
          pointRadius: 3,
          fill: true,
          tension: 0.3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: {
              maxRotation: 45,
              minRotation: 45
            }
          },
          y: {
            beginAtZero: true
          }
        },
        plugins: {
          legend: {
            position: 'top',
          },
          tooltip: {
            callbacks: {
              title: function(tooltipItems) {
                const date = new Date(trendsData[tooltipItems[0].dataIndex].timestamp);
                return date.toLocaleString();
              }
            }
          }
        }
      }
    });
  });
</script>
</file>

<file path="lib/rails_profiler/version.rb">
module RailsProfiler
  VERSION = "1.0.0"
end
</file>

<file path="lib/tasks/rails_profiler_tasks.rake">
namespace :rails_profiler do
  desc "Clean up old profile data from database based on retention period"
  task cleanup: :environment do
    if RailsProfiler.config.storage_backend == :database
      puts "Cleaning up old profile data..."
      deleted_count = RailsProfiler::DatabaseStorage.cleanup_old_profiles
      puts "Cleaned up #{deleted_count} old profiles."
    else
      puts "Cleanup task only applies to database storage backend."
    end
  end
end
</file>

<file path="rails_profiler.gemspec">
Gem::Specification.new do |spec|
  spec.name          = "rails_profiler"
  spec.version       = "1.0.0"
  spec.authors       = ["Your Name"]
  spec.email         = ["your.email@example.com"]
  spec.summary       = "Production Rails profiler with query tracking and dashboard"
  spec.description   = "A comprehensive profiler for Rails applications that tracks queries, code performance, and provides a web dashboard."
  spec.homepage      = "https://github.com/yourusername/rails_profiler"
  spec.license       = "MIT"

  spec.files         = Dir["{app,config,db,lib}/**/*", "MIT-LICENSE", "Rakefile", "README.md"]
  spec.require_paths = ["lib"]

  spec.add_dependency "rails", ">= 5.0"
  spec.add_dependency "redis", ">= 4.0"
  spec.add_dependency "chartkick", ">= 3.0"
  spec.add_dependency "groupdate", ">= 5.0"

  spec.add_development_dependency "rspec-rails"
  spec.add_development_dependency "factory_bot_rails"
  spec.add_development_dependency "sqlite3"
end
</file>

<file path="app/views/rails_profiler/dashboard/index.html.erb">
<div class="container">
  <div class="dashboard-header">
    <h1>Application Performance</h1>
    <div class="dashboard-actions">
      <div class="btn-group" role="group">
        <a href="<%= rails_profiler.root_path(period: 'hour') %>" class="btn <%= params[:period] == 'hour' ? 'btn-primary' : 'btn-outline-primary' %>">Hour</a>
        <a href="<%= rails_profiler.root_path(period: 'day') %>" class="btn <%= params[:period].blank? || params[:period] == 'day' ? 'btn-primary' : 'btn-outline-primary' %>">Day</a>
        <a href="<%= rails_profiler.root_path(period: 'week') %>" class="btn <%= params[:period] == 'week' ? 'btn-primary' : 'btn-outline-primary' %>">Week</a>
      </div>
    </div>
  </div>
  
  <div class="stats-cards">
    <div class="stat-card">
      <h3>Total Requests</h3>
      <div class="stat-value"><%= @stats[:total_profiles] || 0 %></div>
      <% if @stats[:request_change].present? %>
        <div class="stat-trend <%= @stats[:request_change] >= 0 ? 'trend-up' : 'trend-down' %>">
          <i class="fas <%= @stats[:request_change] >= 0 ? 'fa-arrow-up' : 'fa-arrow-down' %>"></i>
          <%= @stats[:request_change].abs %>%
        </div>
      <% end %>
    </div>
    
    <div class="stat-card">
      <h3>Average Response</h3>
      <div class="stat-value"><%= (@stats[:avg_duration] || 0).round(2) %> ms</div>
      <% if @stats[:response_change].present? %>
        <div class="stat-trend <%= @stats[:response_change] <= 0 ? 'trend-up' : 'trend-down' %>">
          <i class="fas <%= @stats[:response_change] <= 0 ? 'fa-arrow-up' : 'fa-arrow-down' %>"></i>
          <%= @stats[:response_change].abs %>%
        </div>
      <% end %>
    </div>
    
    <div class="stat-card">
      <h3>Average Queries</h3>
      <div class="stat-value"><%= (@stats[:avg_queries] || 0).round(1) %></div>
      <% if @stats[:query_count_change].present? %>
        <div class="stat-trend <%= @stats[:query_count_change] <= 0 ? 'trend-up' : 'trend-down' %>">
          <i class="fas <%= @stats[:query_count_change] <= 0 ? 'fa-arrow-up' : 'fa-arrow-down' %>"></i>
          <%= @stats[:query_count_change].abs %>%
        </div>
      <% end %>
    </div>
    
    <div class="stat-card">
      <h3>Average Query Time</h3>
      <div class="stat-value"><%= (@stats[:avg_query_time] || 0).round(2) %> ms</div>
      <% if @stats[:query_time_change].present? %>
        <div class="stat-trend <%= @stats[:query_time_change] <= 0 ? 'trend-up' : 'trend-down' %>">
          <i class="fas <%= @stats[:query_time_change] <= 0 ? 'fa-arrow-up' : 'fa-arrow-down' %>"></i>
          <%= @stats[:query_time_change].abs %>%
        </div>
      <% end %>
    </div>
  </div>

  <div class="row mb-4">
    <div class="col-md-12">
      <div class="card">
        <div class="card-header">
          <h2 class="card-title">Request Volume</h2>
        </div>
        <div class="card-body">
          <div style="height: 200px;">
            <canvas id="requestVolumeChart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="section-header">
    <h2>Top Endpoints</h2>
    <a href="<%= rails_profiler.endpoints_path %>" class="btn btn-sm btn-outline-primary">View All</a>
  </div>

  <div class="endpoints-section">
    <% if @endpoints.present? %>
      <div class="endpoints-list">
        <% @endpoints.take(6).each do |endpoint| %>
          <div class="endpoint-card">
            <div class="endpoint-header">
              <h3 class="endpoint-name">
                <a href="<%= rails_profiler.endpoints_path(endpoint: endpoint[:name]) %>">
                  <%= endpoint[:name] %>
                </a>
              </h3>
              <div class="endpoint-meta">
                <span class="endpoint-count"><%= endpoint[:count] %> requests</span>
                <span class="endpoint-time">
                  <span class="<%= endpoint[:avg_duration] > 500 ? 'text-danger' : (endpoint[:avg_duration] > 200 ? 'text-warning' : 'text-success') %>">
                    <%= endpoint[:avg_duration].round(2) %> ms
                  </span> avg
                </span>
              </div>
            </div>
            
            <div class="endpoint-timeline">
              <% endpoint[:segments].each do |segment| %>
                <div class="segment" 
                     style="width: <%= segment[:percentage].round(1) %>%; background-color: var(--<%= segment[:name].downcase %>-color);"
                     title="<%= segment[:name] %>: <%= segment[:percentage].round(1) %>%"></div>
              <% end %>
            </div>
            
            <div class="endpoint-breakdown">
              <div class="breakdown-item">
                <span class="breakdown-label">Database</span>
                <span class="breakdown-value"><%= endpoint[:avg_db_time]&.round(1) || 0 %> ms</span>
              </div>
              <div class="breakdown-item">
                <span class="breakdown-label">View</span>
                <span class="breakdown-value"><%= endpoint[:avg_view_time]&.round(1) || 0 %> ms</span>
              </div>
              <div class="breakdown-item">
                <span class="breakdown-label">Ruby</span>
                <span class="breakdown-value"><%= endpoint[:avg_ruby_time]&.round(1) || 0 %> ms</span>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    <% else %>
      <div class="no-data">
        <p>No endpoints have been profiled yet.</p>
      </div>
    <% end %>
  </div>

  <div class="section-header">
    <h2>Recent Requests</h2>
    <a href="<%= rails_profiler.profiles_path %>" class="btn btn-sm btn-outline-primary">View All</a>
  </div>

  <div class="table-responsive">
    <table class="table">
      <thead>
        <tr>
          <th>Endpoint</th>
          <th>Path</th>
          <th>Method</th>
          <th>Status</th>
          <th>Duration</th>
          <th>Time</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <% @profiles.each do |profile| %>
          <tr>
            <td>
              <% if profile[:endpoint_name] %>
                <a href="<%= rails_profiler.endpoints_path(endpoint: profile[:endpoint_name]) %>">
                  <%= profile[:endpoint_name] %>
                </a>
              <% else %>
                Unknown
              <% end %>
            </td>
            <td><%= profile[:path].truncate(40) %></td>
            <td>
              <span class="method-badge <%= profile[:method]&.downcase %>"><%= profile[:method] %></span>
            </td>
            <td>
              <span class="status-badge status-<%= profile[:status].to_s[0] %>00">
                <%= profile[:status] %>
              </span>
            </td>
            <td>
              <span class="duration <%= profile[:duration] > 1000 ? 'slow' : (profile[:duration] > 500 ? 'medium' : 'fast') %>">
                <%= profile[:duration].round(2) %> ms
              </span>
              <div class="mini-timeline">
                <% if profile[:db_time] && profile[:duration] > 0 %>
                  <div class="segment db-segment" style="width: <%= ((profile[:db_time] / profile[:duration]) * 100).round(1) %>%"></div>
                <% end %>
                <% if profile[:view_time] && profile[:duration] > 0 %>
                  <div class="segment view-segment" style="width: <%= ((profile[:view_time] / profile[:duration]) * 100).round(1) %>%"></div>
                <% end %>
                <% if profile[:ruby_time] && profile[:duration] > 0 %>
                  <div class="segment ruby-segment" style="width: <%= ((profile[:ruby_time] / profile[:duration]) * 100).round(1) %>%"></div>
                <% end %>
              </div>
            </td>
            <td>
              <span title="<%= profile[:started_at].is_a?(String) ? profile[:started_at] : profile[:started_at].strftime("%Y-%m-%d %H:%M:%S") %>">
                <%= profile[:started_at].is_a?(String) ? profile[:started_at] : time_ago_in_words(profile[:started_at]) %> ago
              </span>
            </td>
            <td>
              <a href="<%= rails_profiler.profile_path(profile[:request_id]) %>" class="btn btn-sm btn-outline-primary">
                View
              </a>
            </td>
          </tr>
        <% end %>
        <% if @profiles.empty? %>
          <tr>
            <td colspan="7" class="text-center py-4">No profiles collected yet</td>
          </tr>
        <% end %>
      </tbody>
    </table>
  </div>

  <% if @stats[:slow_queries].present? %>
    <div class="section-header">
      <h2>Slow Queries</h2>
      <a href="<%= rails_profiler.slowest_queries_path %>" class="btn btn-sm btn-outline-primary">View All</a>
    </div>
    
    <div class="slow-queries-section">
      <% @stats[:slow_queries].take(3).each_with_index do |query, index| %>
        <div class="query-item">
          <div class="query-header">
            <span class="query-number">#<%= index + 1 %></span>
            <span class="query-duration text-danger">
              <%= query[:duration].round(2) %> ms
            </span>
            <span class="query-name">
              <%= query[:name] || "SQL Query" %> in
              <a href="<%= rails_profiler.endpoints_path(endpoint: query[:endpoint_name]) %>">
                <%= query[:endpoint_name] || "Unknown" %>
              </a>
            </span>
          </div>
          
          <div class="query-sql">
            <code><%= query[:sql].truncate(200) %></code>
          </div>
        </div>
      <% end %>
    </div>
  <% end %>
</div>

<style>
  /* Additional styles not in the layout */
  .stat-trend {
    font-size: 0.875rem;
    font-weight: 600;
    margin-top: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }
  
  .trend-up {
    color: var(--success-color);
  }
  
  .trend-down {
    color: var(--danger-color);
  }
</style>

<!-- Chart.js library -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Sample data for the chart (replace with actual data from your controller)
    const volumeData = <%= raw (@volume_data || [
      { timestamp: 1.hour.ago, count: rand(10..30) },
      { timestamp: 50.minutes.ago, count: rand(10..30) },
      { timestamp: 40.minutes.ago, count: rand(10..30) },
      { timestamp: 30.minutes.ago, count: rand(10..30) },
      { timestamp: 20.minutes.ago, count: rand(10..50) },
      { timestamp: 10.minutes.ago, count: rand(10..30) }
    ]).to_json %>;
    
    // Format dates and extract data points
    const labels = volumeData.map(d => {
      const date = new Date(d.timestamp);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    });
    const counts = volumeData.map(d => d.count);
    
    // Create request volume chart
    const requestCtx = document.getElementById('requestVolumeChart').getContext('2d');
    new Chart(requestCtx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: 'Request Count',
          data: counts,
          backgroundColor: 'rgba(60, 118, 242, 0.1)',
          borderColor: 'rgba(60, 118, 242, 0.8)',
          borderWidth: 2,
          pointRadius: 3,
          pointHoverRadius: 5,
          fill: true,
          tension: 0.3,
          cubicInterpolationMode: 'monotone'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            grid: {
              display: false
            }
          },
          y: {
            beginAtZero: true,
            grid: {
              color: 'rgba(0, 0, 0, 0.05)'
            }
          }
        },
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            titleColor: '#1f2937',
            bodyColor: '#1f2937',
            borderColor: 'rgba(0, 0, 0, 0.1)',
            borderWidth: 1,
            padding: 10,
            cornerRadius: 6,
            displayColors: false,
            callbacks: {
              title: function(tooltipItems) {
                return 'Time: ' + tooltipItems[0].label;
              },
              label: function(context) {
                return context.parsed.y + ' requests';
              }
            }
          }
        },
        interaction: {
          mode: 'index',
          intersect: false
        }
      }
    });
  });
</script>
</file>

<file path="app/views/rails_profiler/dashboard/profiles.html.erb">
<div class="container">
  <h1>All Profiles</h1>
  
  <div class="profiles-wrapper">
    <div class="table-responsive">
      <table class="table table-hover">
        <thead>
          <tr>
            <th>Path</th>
            <th>Method</th>
            <th>Status</th>
            <th>Duration (ms)</th>
            <th>Content</th>
            <th>Queries</th>
            <th>Query Time (ms)</th>
            <th>Time</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          <% @profiles.each do |profile| %>
            <tr>
              <td><%= profile[:path] %></td>
              <td><%= profile[:method] %></td>
              <td>
                <span class="status-badge status-<%= profile[:status].to_s[0] %>00">
                  <%= profile[:status] %>
                </span>
              </td>
              <td><%= profile[:duration].round(2) %></td>
              <td>
                <% if profile[:queries].present? && profile[:queries].any? %>
                  <span class="badge bg-info text-white" title="Contains <%= profile[:queries].size %> SQL queries">
                    <i class="fas fa-database"></i> <%= profile[:queries].size %> SQL
                  </span>
                <% end %>
                
                <% 
                  code_profiles = if profile[:additional_data].is_a?(Hash) && profile[:additional_data][:profiles].is_a?(Array)
                                    profile[:additional_data][:profiles]
                                  else
                                    []
                                  end
                %>
                
                <% if code_profiles.present? %>
                  <span class="badge bg-purple text-white" title="Contains <%= code_profiles.size %> code profiles">
                    <i class="fas fa-code"></i> <%= code_profiles.size %> Code
                  </span>
                <% end %>
                
                <% if profile[:status] && profile[:status] >= 400 %>
                  <span class="badge bg-danger text-white" title="Contains errors">
                    <i class="fas fa-exclamation-triangle"></i> Error
                  </span>
                <% end %>
              </td>
              <td><%= profile[:query_count] %></td>
              <td><%= profile[:total_query_time].round(2) %></td>
              <td><%= profile[:started_at].is_a?(String) ? profile[:started_at] : profile[:started_at].strftime("%H:%M:%S") %></td>
              <td>
                <%= link_to "View", rails_profiler.profile_path(profile[:request_id]), class: "btn btn-sm btn-primary" %>
              </td>
            </tr>
          <% end %>
        </tbody>
      </table>
    </div>
    
    <div class="pagination">
      <% if @current_page > 1 %>
        <%= link_to "← Previous", rails_profiler.profiles_path(page: @current_page - 1), class: "btn btn-sm btn-outline-primary" %>
      <% end %>
      
      <% if @profiles.size == 50 %>
        <%= link_to "Next →", rails_profiler.profiles_path(page: @current_page + 1), class: "btn btn-sm btn-outline-primary" %>
      <% end %>
    </div>
  </div>
</div>
</file>

<file path="app/views/rails_profiler/dashboard/slowest_queries.html.erb">
<div class="container">
  <h1>Slowest SQL Queries</h1>
  
  <div class="filter-controls mb-4">
    <form class="form-inline" method="get">
      <div class="form-group mr-2">
        <label for="limit">Limit:</label>
        <select id="limit" name="limit" class="form-control ms-2">
          <option value="20" <%= params[:limit] == "20" ? "selected" : "" %>>20</option>
          <option value="50" <%= params[:limit] == "50" || params[:limit].nil? ? "selected" : "" %>>50</option>
          <option value="100" <%= params[:limit] == "100" ? "selected" : "" %>>100</option>
        </select>
        <button type="submit" class="btn btn-primary ms-2">Apply</button>
      </div>
    </form>
  </div>
  
  <div class="table-responsive">
    <table class="table table-hover">
      <thead>
        <tr>
          <th>Rank</th>
          <th>Duration (ms)</th>
          <th>Query Name</th>
          <th>SQL</th>
          <th>Path</th>
          <th>Time</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <% @slowest_queries.each_with_index do |query, index| %>
          <tr>
            <td>#<%= index + 1 %></td>
            <td>
              <span class="badge bg-<%= query[:duration] > 100 ? 'danger' : (query[:duration] > 50 ? 'warning' : 'success') %>">
                <%= query[:duration].round(2) %>
              </span>
            </td>
            <td><%= query[:name] %></td>
            <td>
              <div class="sql-preview">
                <%= query[:sql].truncate(100) %>
                <% if query[:sql].length > 100 %>
                  <button type="button" class="btn btn-sm btn-link" data-toggle="modal" data-target="#sqlModal<%= index %>">
                    <i class="fas fa-expand-alt"></i> View Full SQL
                  </button>
                <% end %>
              </div>
            </td>
            <td><%= query[:path] %></td>
            <td><%= query[:started_at].is_a?(String) ? query[:started_at] : query[:started_at].strftime("%H:%M:%S") %></td>
            <td>
              <%= link_to "View Profile", rails_profiler.profile_path(query[:request_id]), class: "btn btn-sm btn-primary" %>
            </td>
          </tr>
        <% end %>
      </tbody>
    </table>
  </div>
  
  <div class="mt-4">
    <p class="text-muted">
      Showing top <%= @slowest_queries.size %> slowest queries from the most recent <%= @profiles.size %> requests.
    </p>
  </div>
  
  <!-- Modals for SQL details -->
  <% @slowest_queries.each_with_index do |query, index| %>
    <% if query[:sql].length > 100 %>
      <div class="modal" id="sqlModal<%= index %>" tabindex="-1">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Full SQL Query</h5>
            <span class="close">&times;</span>
          </div>
          <div class="modal-body">
            <p><strong>Query Name:</strong> <%= query[:name] %></p>
            <p><strong>Duration:</strong> <%= query[:duration].round(2) %> ms</p>
            <p><strong>Path:</strong> <%= query[:path] %></p>
            <pre class="sql-full"><%= query[:sql] %></pre>
          </div>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
</file>

<file path="db/migrate/20250519000000_create_rails_profiler_profiles.rb">
class CreateRailsProfilerProfiles < ActiveRecord::Migration[6.0]
  def change
    create_table :rails_profiler_profiles do |t|
      t.string :request_id, null: false, index: { unique: true }
      t.string :url
      t.string :method
      t.string :path
      t.string :controller
      t.string :action
      t.string :endpoint_name
      t.string :format
      t.integer :status
      t.float :duration
      t.integer :query_count
      t.float :total_query_time
      t.float :view_time
      t.float :db_time
      t.float :ruby_time
      t.datetime :started_at
      t.text :queries
      t.text :segments
      t.text :additional_data

      t.timestamps
    end

    add_index :rails_profiler_profiles, :started_at
    add_index :rails_profiler_profiles, :endpoint_name
    add_index :rails_profiler_profiles, [:controller, :action]
  end
end
</file>

<file path="lib/rails_profiler/code_profiler.rb">
module RailsProfiler
  class CodeProfiler
    class << self
      attr_accessor :stack, :filtered_paths
      
      # Initialize stack if not already set
      def stack
        @stack ||= {}
      end
      
      # Set paths to filter out from profiling (like gems)
      def filtered_paths
        @filtered_paths ||= [
          %r{/gems/},
          %r{/ruby/},
          %r{/bin/},
          %r{/vendor/},
          %r{/lib/rails_profiler/}  # Don't profile the profiler itself
        ]
      end
      
      # Profile a block of code with detailed method tracking
      def profile(name = nil, &block)
        return yield unless RailsProfiler.enabled?

        profiler = Thread.current[:rails_profiler_current]
        return yield unless profiler

        # Determine the call location
        location = caller_locations(1, 1).first
        file_path = location.path
        line_number = location.lineno
        method_name = location.label
        
        # Skip if this is in a filtered path (like gems)
        return yield if should_filter_path?(file_path)
        
        # Generate a name if not provided
        name ||= "#{File.basename(file_path)}:#{line_number}:#{method_name}"
        
        # Track parent method for building call graph
        thread_id = Thread.current.object_id
        parent_method = stack[thread_id]&.last
        
        # Get initial memory usage
        start_memory = get_memory_usage if RailsProfiler.config.track_memory

        # Start timing
        start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
        
        # Add this method to the calling stack
        stack[thread_id] ||= []
        stack[thread_id].push(name)
        
        begin
          result = yield
        ensure
          # End timing
          end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
          duration = (end_time - start_time) * 1000
          
          # Calculate memory usage if configured
          memory_delta = nil
          if RailsProfiler.config.track_memory && start_memory
            end_memory = get_memory_usage
            memory_delta = end_memory - start_memory
          end
          
          # Remove from stack
          stack[thread_id].pop
          stack.delete(thread_id) if stack[thread_id]&.empty?
          
          # Determine method type (controller, model, view, etc.)
          method_type = determine_method_type(file_path, method_name, name)
          
          # Record profiling data
          profiler.add_code_profile({
            name: name,
            method_name: method_name,
            method_type: method_type,
            file_path: file_path,
            line_number: line_number,
            duration: duration,
            exclusive_duration: calculate_exclusive_duration(profiler, name, duration),
            memory_delta: memory_delta,
            parent: parent_method,
            started_at: start_time,
            backtrace: caller[0..5]
          })
        end
        
        result
      end
      
      # Profile a specific method in any class
      def profile_method(klass, method_name, options = {})
        return unless RailsProfiler.enabled?
        
        # Skip if already profiled
        method_id = "#{klass.name}##{method_name}"
        return if @profiled_methods&.include?(method_id)
        
        # Track profiled methods to avoid duplicates
        @profiled_methods ||= Set.new
        @profiled_methods << method_id
        
        # Save the original method
        klass.class_eval do
          alias_method :"#{method_name}_without_profiling", method_name
          
          define_method(method_name) do |*args, &block|
            RailsProfiler::CodeProfiler.profile("#{klass.name}##{method_name}") do
              send(:"#{method_name}_without_profiling", *args, &block)
            end
          end
        end
      end
      
      # Automatically profile all controller actions
      def profile_controllers
        return unless RailsProfiler.enabled?
        
        if defined?(ActionController::Base)
          ActionController::Base.class_eval do
            def process_action(*args)
              controller_name = self.class.name
              action_name = self.action_name
              profile_name = "#{controller_name}##{action_name}"
              
              params_data = request.params.except('controller', 'action').to_h
              
              # Track request details
              Thread.current[:rails_profiler_request] = {
                controller: controller_name,
                action: action_name,
                method: request.method,
                path: request.path,
                format: request.format.try(:to_sym),
                params: params_data
              }
              
              RailsProfiler::CodeProfiler.profile(profile_name) do
                super
              end
            end
          end
        end
      end
      
      # Profile ActiveRecord model methods
      def profile_models
        return unless RailsProfiler.enabled?
        
        if defined?(ActiveRecord::Base)
          # Profile common ActiveRecord methods
          model_methods = [
            :find, :find_by, :where, :create, :update, :destroy,
            :save, :save!, :update_attributes, :update_attributes!
          ]
          
          model_methods.each do |method_name|
            if ActiveRecord::Base.respond_to?(method_name)
              profile_method(ActiveRecord::Base.singleton_class, method_name)
            end
          end
          
          if ActiveRecord::Base.respond_to?(:find_by_sql)
            # Profile all database queries
            ActiveRecord::Base.singleton_class.class_eval do
              alias_method :find_by_sql_without_profiling, :find_by_sql
              
              def find_by_sql(sql, binds = [], preparable: nil, &block)
                RailsProfiler::CodeProfiler.profile("ActiveRecord::Base.find_by_sql") do
                  find_by_sql_without_profiling(sql, binds, preparable: preparable, &block)
                end
              end
            end
          end
        end
      end
      
      # Profile view rendering - improved to handle all argument combinations
      def profile_views
        return unless RailsProfiler.enabled?
        
        if defined?(ActionView::Template)
          ActionView::Template.class_eval do
            alias_method :render_without_profiling, :render
            
            # Update the render method to properly handle all argument types
            # We support all combinations of arguments that Rails itself supports
            def render(*args, **kwargs, &block)
              template_path = virtual_path || identifier
              RailsProfiler::CodeProfiler.profile("Render: #{template_path}") do
                if kwargs.empty?
                  render_without_profiling(*args, &block)
                else
                  render_without_profiling(*args, **kwargs, &block)
                end
              end
            end
          end
        end
      end
      
      # Setup profiling for configured methods from config.auto_profile_methods
      def profile_configured_methods
        return unless RailsProfiler.enabled?
        
        configured_methods = RailsProfiler.config.auto_profile_methods
        return if configured_methods.empty?
        
        configured_methods.each do |method_pattern|
          # Handle patterns like 'User#*' (all methods in User) or 'Post#save' (specific method)
          if method_pattern.include?('#')
            class_name, method_pattern = method_pattern.split('#', 2)
            
            # Find the class
            klass = class_name.constantize rescue nil
            next unless klass
            
            if method_pattern == '*'
              # Profile all instance methods in the class
              klass.instance_methods(false).each do |method_name|
                profile_method(klass, method_name)
              end
            else
              # Profile specific method
              profile_method(klass, method_pattern.to_sym) if klass.method_defined?(method_pattern)
            end
          elsif method_pattern.include?('.')
            # Handle static/class methods like 'User.find_by_email'
            class_name, method_pattern = method_pattern.split('.', 2)
            
            # Find the class
            klass = class_name.constantize rescue nil
            next unless klass
            
            if method_pattern == '*'
              # Profile all class methods
              klass.singleton_class.instance_methods(false).each do |method_name|
                profile_method(klass.singleton_class, method_name)
              end
            else
              # Profile specific class method
              profile_method(klass.singleton_class, method_pattern.to_sym) if klass.singleton_class.method_defined?(method_pattern)
            end
          end
        end
      end
      
      # Calculate exclusive duration (time spent in the method itself, not in called methods)
      def calculate_exclusive_duration(profiler, method_name, duration)
        # This calculation might need to be implemented depending on your profiler's internal structure
        # For now, we'll just return the full duration
        duration
      end
      
      # Determine if a path should be filtered out
      def should_filter_path?(path)
        filtered_paths.any? { |pattern| path =~ pattern }
      end
      
      # Get current memory usage in KB
      def get_memory_usage
        # This works on Linux/macOS, adjust for other platforms as needed
        if RUBY_PLATFORM =~ /darwin/
          `ps -o rss= -p #{Process.pid}`.to_i
        elsif RUBY_PLATFORM =~ /linux/
          File.read("/proc/#{Process.pid}/statm").split(' ')[0].to_i * (Process.page_size / 1024)
        else
          0 # Unsupported platform
        end
      end
      
      # Determine the type of method (controller, model, view, etc.)
      def determine_method_type(file_path, method_name, name)
        if file_path =~ /controllers/
          'controller'
        elsif file_path =~ /models/
          'model'
        elsif file_path =~ /views/ || name.start_with?('Render:')
          'view'
        elsif file_path =~ /jobs/
          'job'
        elsif file_path =~ /services/
          'service'
        elsif file_path =~ /helpers/
          'helper'
        else
          'other'
        end
      end
    end
  end
  
  # Hook to set up automatic profiling
  class Engine < ::Rails::Engine
    initializer "rails_profiler.setup_profiling" do
      if RailsProfiler.config.profile_controllers
        CodeProfiler.profile_controllers 
      end
      
      if RailsProfiler.config.profile_models
        CodeProfiler.profile_models
      end
      
      # Set up automatic profiling of configured methods
      CodeProfiler.profile_configured_methods
      
      # Set up view profiling - now handled by profile_views method to avoid duplicating the patch
      if RailsProfiler.config.track_code && defined?(ActionView::Template)
        CodeProfiler.profile_views
      end
    end
  end
end
</file>

<file path="lib/rails_profiler/query_tracker.rb">
require "active_record"

module RailsProfiler
  class QueryTracker
    def self.install!
      Rails.logger.info "[RailsProfiler] Installing QueryTracker"
      
      ActiveSupport::Notifications.subscribe("sql.active_record") do |*args|
        event = ActiveSupport::Notifications::Event.new(*args)
        profiler = Thread.current[:rails_profiler_current]
        
        if profiler && !ignored_query?(event.payload[:sql])
          Rails.logger.debug "[RailsProfiler] QueryTracker captured SQL query: #{event.payload[:sql].truncate(100)}" if rand < 0.1
          
          query_data = {
            sql: event.payload[:sql],
            name: event.payload[:name],
            duration: event.duration,
            started_at: event.time
          }
          
          if event.payload[:binds].present? && event.payload[:type_casted_binds].respond_to?(:call)
            binds = event.payload[:type_casted_binds].call(event.payload[:binds])
            query_data[:binds] = binds.map(&:to_s) if binds.present?
          end
          
          if collect_backtrace?
            query_data[:backtrace] = clean_backtrace(caller)
          end
          
          profiler.add_query(query_data)
        end
      end
      
      Rails.logger.info "[RailsProfiler] QueryTracker successfully installed"
    end
    
    private
    
    def self.ignored_query?(sql)
      sql =~ /\A(BEGIN|COMMIT|ROLLBACK|RELEASE|SAVEPOINT)/i
    end
    
    def self.collect_backtrace?
      true # Could make this configurable
    end
    
    def self.clean_backtrace(backtrace)
      app_root = Rails.root.to_s
      
      backtrace
        .select { |line| line.include?(app_root) }
        .map { |line| line.sub(app_root, '') }
        .first(10)
    end
  end
end
</file>

<file path="README.md">
# Rails Profiler

A comprehensive profiler for Rails applications that tracks database queries, code performance, and provides a web dashboard for production environments.

## Features

- **Query Tracking**: Automatically tracks all SQL queries with execution time and backtrace
- **Code Profiling**: Profile specific code blocks with the `RailsProfiler.profile` method
- **Production Ready**: Configurable sampling rate to minimize overhead
- **Web Dashboard**: Built-in Rails engine with authentication for viewing profiles
- **Multiple Storage Backends**: Redis (default) and database storage options
- **Configurable Retention**: Automatic cleanup of old profile data

## Installation

Add this gem to your Rails application's Gemfile:

```ruby
gem 'rails_profiler'
```

Then execute:
```bash
bundle install
```

If you plan to use the database storage backend, run the migrations:

```bash
rails rails_profiler:install:migrations
rails db:migrate
```

## Configuration

Create an initializer `config/initializers/rails_profiler.rb`:

```ruby
RailsProfiler.configure do |config|
  config.enabled = Rails.env.production? || Rails.env.staging?
  
  # Choose a storage backend: :redis or :database
  config.storage_backend = :redis
  
  # Redis configuration (only needed if using Redis backend)
  config.redis_url = ENV.fetch('REDIS_URL', 'redis://localhost:6379/0')
  
  config.sample_rate = 0.1 # Profile 10% of requests
  config.track_queries = true
  config.track_code = true
  config.retention_days = 7
  config.dashboard_username = ENV.fetch('PROFILER_USERNAME', 'admin')
  config.dashboard_password = ENV.fetch('PROFILER_PASSWORD', 'password')
end
```

## Usage

### Manual Code Profiling

```ruby
# Profile a specific block of code
RailsProfiler.profile("expensive_operation") do
  # Your code here
  User.expensive_calculation
end

# Profile with automatic naming based on location
RailsProfiler.profile do
  # This will be named based on the file and line
  perform_complex_task
end
```

### Dashboard Access

Mount the dashboard in your routes (`config/routes.rb`):

```ruby
mount RailsProfiler::Engine => '/profiler'
```

Visit `/profiler` in your application and log in with your configured credentials.

## Dashboard Features

- **Overview Statistics**: Average response times, query counts, and performance metrics
- **Profile List**: Browse all captured profiles with filtering options
- **Detailed Views**: Drill down into individual requests to see:
  - All executed SQL queries with execution times
  - Code profile blocks with durations
  - Full backtraces for debugging

## Storage Options

### Redis (Default)
Stores profiles in Redis with automatic expiration based on retention settings.

### Database
Stores profiles in your application's database using ActiveRecord:

1. Runs automatically with the migration
2. Uses the `rails_profiler_profiles` table 
3. Keeps database size in check with an automatic cleanup task

To clean up old profiles when using database storage:

```bash
# Run manually or in a cron job
rails rails_profiler:cleanup
```

## Security

The dashboard is protected with HTTP Basic Authentication. Make sure to:
1. Use strong credentials in production
2. Consider additional security measures (IP restrictions, VPN access, etc.)
3. Monitor access logs

## Performance Impact

The profiler is designed for production use:
- Configurable sampling rate (default: 10% of requests)
- Minimal overhead when disabled
- Efficient storage with automatic cleanup
- Non-blocking query tracking

## License

MIT License - see LICENSE file for details.
</file>

<file path="app/controllers/rails_profiler/dashboard_controller.rb">
module RailsProfiler
  class DashboardController < ApplicationController
    def index
      @stats = Storage.get_summary_stats
      @profiles = @stats[:latest_profiles] || []
      @endpoints = @stats[:endpoints] || []
    end

    def show
      @profile = Storage.get_profile(params[:id])
      redirect_to rails_profiler.root_path unless @profile
    end

    def profiles
      page = (params[:page] || 1).to_i
      per_page = 50
      offset = (page - 1) * per_page
      
      @profiles = Storage.get_profiles(limit: per_page, offset: offset)
      @current_page = page
    end
    
    def endpoints
      @stats = Storage.get_summary_stats
      @endpoints = @stats[:endpoints] || []
      
      # Allow filtering by specific endpoint
      if params[:endpoint]
        @selected_endpoint = params[:endpoint]
        @endpoint_profiles = Storage.get_profiles_by_endpoint(@selected_endpoint, limit: 100)
      end
    end
    
    def trends
      days = (params[:days] || 7).to_i
      @trends_data = Storage.get_trends(days: days)
    end
    
    def slowest_queries
      limit = (params[:limit] || 50).to_i
      @profiles = Storage.get_profiles(limit: 200) # Get more profiles to find slow queries
      
      # Extract all queries from profiles
      all_queries = []
      @profiles.each do |profile|
        profile[:queries].each do |query|
          all_queries << {
            sql: query[:sql],
            duration: query[:duration],
            name: query[:name],
            request_id: profile[:request_id],
            path: profile[:path],
            started_at: profile[:started_at],
            endpoint_name: profile[:endpoint_name]
          }
        end
      end
      
      # Sort queries by duration (slowest first) and limit
      @slowest_queries = all_queries.sort_by { |q| -q[:duration] }.first(limit)
    end
    
    def hotspots
      # Get recent profiles to analyze hotspots
      @profiles = Storage.get_profiles(limit: 500)
      
      # Initialize hotspot data structure
      hotspots = {
        controllers: {},
        methods: {},
        models: {},
        views: {}
      }
      
      # Aggregate hotspot data from all profiles
      @profiles.each do |profile|
        if profile[:additional_data].is_a?(Hash) && 
           profile[:additional_data][:hotspots].is_a?(Hash)
          
          # Merge controller hotspots
          profile_hotspots = profile[:additional_data][:hotspots]
          
          # Aggregate controller hotspots
          if profile_hotspots[:controllers].is_a?(Array)
            profile_hotspots[:controllers].each do |controller|
              name = controller[:name]
              hotspots[:controllers][name] ||= { total_time: 0, count: 0, actions: {} }
              hotspots[:controllers][name][:total_time] += controller[:value]
              hotspots[:controllers][name][:count] += 1
              
              if controller[:data][:actions].is_a?(Hash)
                controller[:data][:actions].each do |action, action_data|
                  hotspots[:controllers][name][:actions][action] ||= { total_time: 0, count: 0 }
                  hotspots[:controllers][name][:actions][action][:total_time] += action_data[:total_time]
                  hotspots[:controllers][name][:actions][action][:count] += action_data[:count]
                end
              end
            end
          end
          
          # Aggregate method hotspots
          if profile_hotspots[:methods].is_a?(Array)
            profile_hotspots[:methods].each do |method|
              name = method[:name]
              hotspots[:methods][name] ||= { exclusive_time: 0, total_time: 0, count: 0 }
              hotspots[:methods][name][:exclusive_time] += method[:value]
              hotspots[:methods][name][:total_time] += method[:data][:total_time]
              hotspots[:methods][name][:count] += method[:data][:count]
            end
          end
          
          # Aggregate model hotspots
          if profile_hotspots[:models].is_a?(Array)
            profile_hotspots[:models].each do |model|
              name = model[:name]
              hotspots[:models][name] ||= { total_time: 0, count: 0 }
              hotspots[:models][name][:total_time] += model[:value]
              hotspots[:models][name][:count] += model[:data][:count]
            end
          end
          
          # Aggregate view hotspots
          if profile_hotspots[:views].is_a?(Array)
            profile_hotspots[:views].each do |view|
              name = view[:name]
              hotspots[:views][name] ||= { total_time: 0, count: 0 }
              hotspots[:views][name][:total_time] += view[:value]
              hotspots[:views][name][:count] += view[:data][:count]
            end
          end
        end
      end
      
      # Format the data for the view
      @hotspots = {
        controllers: format_hotspot_data(hotspots[:controllers], :total_time, 10),
        methods: format_hotspot_data(hotspots[:methods], :exclusive_time, 20),
        models: format_hotspot_data(hotspots[:models], :total_time, 10),
        views: format_hotspot_data(hotspots[:views], :total_time, 10)
      }
      
      # Get maximum times for scaling progress bars
      @max_controller_time = @hotspots[:controllers].first[:value] rescue 100
      @max_method_time = @hotspots[:methods].first[:value] rescue 100
    end
    
    private
    
    def format_hotspot_data(data_hash, value_key, limit)
      data_hash.map do |name, data|
        {
          name: name,
          value: data[value_key],
          data: data
        }
      end.sort_by { |item| -item[:value] }.take(limit)
    end
  end
end
</file>

<file path="app/views/layouts/rails_profiler/application.html.erb">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rails Profiler</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Main colors */
      --primary-color: #4f46e5;
      --primary-dark: #3730a3;
      --primary-light: #a5b4fc;
      --secondary-color: #14b8a6;
      --gray-color: #6b7280;
      --light-gray: #f3f4f6;
      --dark-gray: #374151;
      --black: #111827;
      --white: #ffffff;
      
      /* Status colors */
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --danger-color: #ef4444;
      
      /* Specific component colors */
      --db-color: #0ea5e9;
      --view-color: #ec4899;
      --ruby-color: #8b5cf6;
      --controller-color: #f59e0b;

      /* Fonts */
      --font-sans: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-sans);
      color: var(--dark-gray);
      background-color: #f9fafb;
      font-size: 14px;
      line-height: 1.5;
    }

    /* Layout */
    .app-container {
      display: flex;
      min-height: 100vh;
    }

    .sidebar {
      background-color: var(--white);
      width: 240px;
      flex-shrink: 0;
      border-right: 1px solid #e5e7eb;
      position: fixed;
      height: 100vh;
      overflow-y: auto;
    }

    .content-wrapper {
      flex-grow: 1;
      margin-left: 240px;
      padding: 2rem;
    }

    .logo {
      padding: 1.5rem;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #e5e7eb;
    }

    .logo-text {
      font-weight: 600;
      font-size: 1.25rem;
      color: var(--primary-color);
      margin-left: 0.5rem;
    }

    .nav-menu {
      padding: 1rem 0;
    }

    .nav-section {
      margin-bottom: 1rem;
    }

    .nav-section-title {
      padding: 0.5rem 1.5rem;
      font-size: 0.75rem;
      text-transform: uppercase;
      font-weight: 600;
      color: var(--gray-color);
      letter-spacing: 0.05em;
    }

    .nav-link {
      padding: 0.75rem 1.5rem;
      display: flex;
      align-items: center;
      color: var(--dark-gray);
      text-decoration: none;
      font-weight: 500;
      transition: background-color 0.2s ease-in-out;
    }

    .nav-link:hover {
      background-color: #f9fafb;
      color: var(--primary-color);
    }

    .nav-link.active {
      color: var(--primary-color);
      background-color: rgba(79, 70, 229, 0.08);
      border-left: 3px solid var(--primary-color);
      padding-left: calc(1.5rem - 3px);
    }

    .nav-link i {
      width: 20px;
      margin-right: 0.75rem;
    }

    /* Container */
    .container {
      max-width: 1280px;
      margin: 0 auto;
    }

    /* Cards */
    .card {
      background-color: var(--white);
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
      margin-bottom: 1.5rem;
    }

    .card-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--black);
      margin: 0;
    }

    .card-body {
      padding: 1.5rem;
    }

    /* Tables */
    .table {
      width: 100%;
      border-collapse: collapse;
    }

    .table th,
    .table td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }

    .table th {
      font-weight: 600;
      font-size: 0.875rem;
      color: var(--gray-color);
    }

    .table tbody tr:last-child td {
      border-bottom: none;
    }

    .table tbody tr:hover {
      background-color: #f9fafb;
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.5rem 1rem;
      font-weight: 500;
      border-radius: 0.375rem;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      border: 1px solid transparent;
    }

    .btn-sm {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
      border-radius: 0.25rem;
    }

    .btn-primary {
      background-color: var(--primary-color);
      color: var(--white);
    }

    .btn-primary:hover {
      background-color: var(--primary-dark);
    }

    .btn-outline-primary {
      border-color: var(--primary-color);
      color: var(--primary-color);
      background-color: transparent;
    }

    .btn-outline-primary:hover {
      background-color: rgba(79, 70, 229, 0.08);
    }

    .btn-outline-secondary {
      border-color: #cbd5e1;
      color: var(--gray-color);
      background-color: transparent;
    }

    .btn-outline-secondary:hover {
      background-color: #f3f4f6;
    }

    /* Dashboard */
    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
    }

    .dashboard-header h1 {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--black);
    }

    .dashboard-actions {
      display: flex;
      gap: 0.5rem;
    }

    .stats-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 1rem;
    }

    .stat-card {
      background-color: var(--white);
      border-radius: 0.5rem;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
    }

    .stat-card h3 {
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--gray-color);
      margin-bottom: 0.5rem;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--black);
      margin-bottom: 0.5rem;
    }

    /* Profiles */
    .profile-list {
      background-color: var(--white);
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
    }

    .profile-item {
      padding: 1rem;
      border-bottom: 1px solid #e5e7eb;
      transition: background-color 0.2s ease-in-out;
    }

    .profile-item:last-child {
      border-bottom: none;
    }

    .profile-item:hover {
      background-color: #f9fafb;
    }

    .profile-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .profile-endpoint {
      font-weight: 600;
      color: var(--black);
    }

    .profile-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .meta-label {
      font-weight: 500;
      color: var(--gray-color);
    }

    .duration {
      font-weight: 600;
      border-radius: 1rem;
      padding: 0.125rem 0.5rem;
      font-size: 0.875rem;
    }

    .duration.slow {
      background-color: rgba(239, 68, 68, 0.1);
      color: var(--danger-color);
    }

    .duration.medium {
      background-color: rgba(245, 158, 11, 0.1);
      color: var(--warning-color);
    }

    .duration.fast {
      background-color: rgba(16, 185, 129, 0.1);
      color: var(--success-color);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
    }

    .status-200 {
      background-color: rgba(16, 185, 129, 0.1);
      color: var(--success-color);
    }

    .status-300 {
      background-color: rgba(14, 165, 233, 0.1);
      color: var(--db-color);
    }

    .status-400, .status-500 {
      background-color: rgba(239, 68, 68, 0.1);
      color: var(--danger-color);
    }

    /* Timeline */
    .timeline-section {
      margin-bottom: 2rem;
    }

    .section-header {
      margin-bottom: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .section-header h2, 
    .section-header h3, 
    .section-header h4 {
      font-weight: 600;
      color: var(--black);
      margin: 0;
    }

    .time-scale {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.75rem;
      color: var(--gray-color);
    }

    .timeline-breakdown {
      display: grid;
      grid-template-columns: 120px 1fr 60px;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
    }

    .timeline-label {
      font-size: 0.875rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .timeline-track {
      height: 24px;
      background-color: #f3f4f6;
      border-radius: 4px;
      position: relative;
      overflow: hidden;
    }

    .timeline-segment {
      position: absolute;
      height: 100%;
      top: 0;
      min-width: 1px;
    }

    .db-segment {
      background-color: var(--db-color);
    }

    .view-segment {
      background-color: var(--view-color);
    }

    .controller-segment {
      background-color: var(--controller-color);
    }

    .ruby-segment {
      background-color: var(--ruby-color);
    }

    .timeline-duration {
      text-align: right;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .mini-timeline {
      height: 6px;
      background-color: #f3f4f6;
      border-radius: 3px;
      position: relative;
      overflow: hidden;
      margin-top: 0.5rem;
    }

    .segment {
      height: 100%;
    }

    /* Queries section */
    .queries-section {
      margin-bottom: 2rem;
    }

    .query-item {
      background-color: var(--white);
      border-radius: 0.5rem;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .query-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
      gap: 0.75rem;
    }

    .query-number {
      font-weight: 600;
      color: var(--gray-color);
      background-color: #f3f4f6;
      border-radius: 0.25rem;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
    }

    .query-duration {
      font-weight: 600;
      font-size: 0.875rem;
    }

    .query-name {
      font-weight: 500;
      font-size: 0.875rem;
    }

    .query-sql {
      background-color: #f3f4f6;
      padding: 0.75rem;
      border-radius: 0.375rem;
      font-family: 'SF Mono', SFMono-Regular, ui-monospace, Menlo, Monaco, Consolas, monospace;
      font-size: 0.75rem;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-all;
      color: var(--dark-gray);
    }

    .text-danger {
      color: var(--danger-color);
    }

    .text-warning {
      color: var(--warning-color);
    }

    .text-success {
      color: var(--success-color);
    }

    /* Modals */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 10% auto;
      max-width: 600px;
      width: 90%;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .modal-header {
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #e5e7eb;
    }

    .modal-body {
      padding: 1rem;
      max-height: 60vh;
      overflow-y: auto;
    }

    .close {
      cursor: pointer;
      font-size: 1.5rem;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .sidebar {
        width: 64px;
      }
      
      .content-wrapper {
        margin-left: 64px;
      }
      
      .logo-text {
        display: none;
      }
      
      .nav-link span {
        display: none;
      }
      
      .nav-section-title {
        display: none;
      }
      
      .nav-link {
        justify-content: center;
        padding: 0.75rem;
      }
      
      .nav-link i {
        margin-right: 0;
      }
      
      .stats-cards {
        grid-template-columns: 1fr;
      }
      
      .timeline-breakdown {
        grid-template-columns: 80px 1fr 50px;
      }
    }
    
    /* Utility classes */
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mt-4 { margin-top: 1rem; }
    .mb-1 { margin-bottom: 0.25rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-3 { margin-bottom: 0.75rem; }
    .mb-4 { margin-bottom: 1rem; }
  </style>
  <%= yield :head %>
</head>
<body>
  <div class="app-container">
    <div class="sidebar">
      <div class="logo">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="logo-icon" style="color: var(--primary-color);">
          <path d="M12 2v4"></path>
          <path d="M12 18v4"></path>
          <path d="m4.93 4.93 2.83 2.83"></path>
          <path d="m16.24 16.24 2.83 2.83"></path>
          <path d="M2 12h4"></path>
          <path d="M18 12h4"></path>
          <path d="m4.93 19.07 2.83-2.83"></path>
          <path d="m16.24 7.76 2.83-2.83"></path>
        </svg>
        <span class="logo-text">Rails Profiler</span>
      </div>
      
      <div class="nav-menu">
        <div class="nav-section">
          <div class="nav-section-title">Dashboard</div>
          <a href="<%= rails_profiler.root_path %>" class="nav-link <%= request.path == rails_profiler.root_path ? 'active' : '' %>">
            <i class="fas fa-chart-line"></i>
            <span>Overview</span>
          </a>
          <a href="<%= rails_profiler.profiles_path %>" class="nav-link <%= request.path == rails_profiler.profiles_path ? 'active' : '' %>">
            <i class="fas fa-list"></i>
            <span>Requests</span>
          </a>
          <a href="<%= rails_profiler.endpoints_path %>" class="nav-link <%= request.path == rails_profiler.endpoints_path ? 'active' : '' %>">
            <i class="fas fa-sitemap"></i>
            <span>Endpoints</span>
          </a>
          <a href="<%= rails_profiler.slowest_queries_path %>" class="nav-link <%= request.path == rails_profiler.slowest_queries_path ? 'active' : '' %>">
            <i class="fas fa-database"></i>
            <span>Slow Queries</span>
          </a>
          <a href="<%= rails_profiler.trends_path %>" class="nav-link <%= request.path == rails_profiler.trends_path ? 'active' : '' %>">
            <i class="fas fa-chart-bar"></i>
            <span>Trends</span>
          </a>
        </div>
        
        <div class="nav-section">
          <div class="nav-section-title">Settings</div>
          <a href="#" class="nav-link">
            <i class="fas fa-cog"></i>
            <span>Configuration</span>
          </a>
          <a href="#" class="nav-link">
            <i class="fas fa-question-circle"></i>
            <span>Help</span>
          </a>
        </div>
      </div>
    </div>
    
    <div class="content-wrapper">
      <%= yield %>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Handle modal functionality
      const modalTriggers = document.querySelectorAll('[data-toggle="modal"]');
      modalTriggers.forEach(function(trigger) {
        trigger.addEventListener('click', function() {
          const target = document.querySelector(this.dataset.target);
          if (target) {
            target.style.display = "block";
          }
        });
      });
      
      const modalCloses = document.querySelectorAll('.close');
      modalCloses.forEach(function(close) {
        close.addEventListener('click', function() {
          const modal = this.closest('.modal');
          if (modal) {
            modal.style.display = "none";
          }
        });
      });

      // Close modal when clicking outside
      window.addEventListener('click', function(event) {
        if (event.target.classList.contains('modal')) {
          event.target.style.display = "none";
        }
      });
    });
  </script>
  
  <%= yield :scripts %>
</body>
</html>
</file>

<file path="app/views/rails_profiler/dashboard/show.html.erb">
<div class="container profile-detail">
  <div class="back-link">
    <a href="<%= rails_profiler.profiles_path %>" class="btn btn-sm btn-outline-primary">
      <i class="fas fa-arrow-left"></i> Back to Requests
    </a>
  </div>

  <div class="dashboard-header">
    <h1>
      <%= @profile[:endpoint_name] || "Unknown Endpoint" %>
      <small class="text-muted"><%= @profile[:method] %> <%= @profile[:path] %></small>
    </h1>
    
    <div class="dashboard-actions">
      <span class="status-badge status-<%= @profile[:status].to_s[0] %>00">
        <%= @profile[:status] %>
      </span>
    </div>
  </div>

  <div class="profile-meta">
    <div class="meta-item">
      <span class="meta-label">Request ID:</span>
      <span><%= @profile[:request_id] %></span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Time:</span>
      <span><%= @profile[:started_at].is_a?(String) ? @profile[:started_at] : @profile[:started_at].strftime("%Y-%m-%d %H:%M:%S") %></span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Duration:</span>
      <span class="duration <%= @profile[:duration] > 1000 ? 'slow' : (@profile[:duration] > 500 ? 'medium' : 'fast') %>">
        <%= @profile[:duration].round(2) %> ms
      </span>
    </div>
    <% if @profile[:params].present? && !@profile[:params].empty? %>
      <div class="meta-item">
        <span class="meta-label">Parameters:</span>
        <button class="btn btn-sm btn-outline-secondary" data-toggle="modal" data-target="#paramsModal">
          View Params
        </button>
      </div>
    <% end %>
  </div>

  <div class="timeline-section">
    <h3 class="section-header">Request Timeline</h3>
    
    <div class="time-scale">
      <span>0 ms</span>
      <span><%= @profile[:duration].round %> ms</span>
    </div>
    
    <div class="timeline-breakdown">
      <div class="timeline-label">Total</div>
      <div class="timeline-track">
        <% if @profile[:db_time] %>
          <div class="timeline-segment db-segment" style="width: <%= ((@profile[:db_time] / @profile[:duration]) * 100).round(1) %>%; left: <%= @profile[:db_offset] || 0 %>%;" title="Database: <%= @profile[:db_time].round(2) %> ms"></div>
        <% end %>
        
        <% if @profile[:view_time] %>
          <div class="timeline-segment view-segment" style="width: <%= ((@profile[:view_time] / @profile[:duration]) * 100).round(1) %>%; left: <%= @profile[:view_offset] || 0 %>%;" title="View: <%= @profile[:view_time].round(2) %> ms"></div>
        <% end %>
        
        <% if @profile[:controller_time] %>
          <div class="timeline-segment controller-segment" style="width: <%= ((@profile[:controller_time] / @profile[:duration]) * 100).round(1) %>%; left: <%= @profile[:controller_offset] || 0 %>%;" title="Controller: <%= @profile[:controller_time].round(2) %> ms"></div>
        <% end %>
        
        <% if @profile[:ruby_time] %>
          <div class="timeline-segment ruby-segment" style="width: <%= ((@profile[:ruby_time] / @profile[:duration]) * 100).round(1) %>%; left: <%= @profile[:ruby_offset] || 0 %>%;" title="Ruby: <%= @profile[:ruby_time].round(2) %> ms"></div>
        <% end %>
      </div>
      <div class="timeline-duration">
        <%= @profile[:duration].round(2) %> ms
      </div>
    </div>
    
    <div class="card mt-4">
      <div class="card-header">
        <h4 class="card-title">Time Breakdown</h4>
      </div>
      <div class="card-body">
        <div class="stats-cards">
          <% if @profile[:db_time] %>
            <div class="stat-card">
              <h3>Database Time</h3>
              <div class="stat-value" style="color: var(--db-color);">
                <%= @profile[:db_time].round(2) %> ms
              </div>
              <div class="mini-timeline">
                <div class="segment db-segment" style="width: 100%;"></div>
              </div>
              <div class="stat-percentage mt-2">
                <%= ((@profile[:db_time] / @profile[:duration]) * 100).round(1) %>% of request
              </div>
            </div>
          <% end %>

          <% if @profile[:view_time] %>
            <div class="stat-card">
              <h3>View Time</h3>
              <div class="stat-value" style="color: var(--view-color);">
                <%= @profile[:view_time].round(2) %> ms
              </div>
              <div class="mini-timeline">
                <div class="segment view-segment" style="width: 100%;"></div>
              </div>
              <div class="stat-percentage mt-2">
                <%= ((@profile[:view_time] / @profile[:duration]) * 100).round(1) %>% of request
              </div>
            </div>
          <% end %>

          <% if @profile[:ruby_time] %>
            <div class="stat-card">
              <h3>Ruby Time</h3>
              <div class="stat-value" style="color: var(--ruby-color);">
                <%= @profile[:ruby_time].round(2) %> ms
              </div>
              <div class="mini-timeline">
                <div class="segment ruby-segment" style="width: 100%;"></div>
              </div>
              <div class="stat-percentage mt-2">
                <%= ((@profile[:ruby_time] / @profile[:duration]) * 100).round(1) %>% of request
              </div>
            </div>
          <% end %>

          <% if @profile[:controller_time] %>
            <div class="stat-card">
              <h3>Controller Time</h3>
              <div class="stat-value" style="color: var(--controller-color);">
                <%= @profile[:controller_time].round(2) %> ms
              </div>
              <div class="mini-timeline">
                <div class="segment" style="width: 100%; background-color: var(--controller-color);"></div>
              </div>
              <div class="stat-percentage mt-2">
                <%= ((@profile[:controller_time] / @profile[:duration]) * 100).round(1) %>% of request
              </div>
            </div>
          <% end %>
        </div>
      </div>
    </div>
    
    <% if @profile[:detailed_segments].present? %>
      <div class="detailed-timeline">
        <h4 class="mb-3">Detailed View</h4>
        
        <% @profile[:detailed_segments].each do |segment| %>
          <div class="timeline-breakdown">
            <div class="timeline-label" title="<%= segment[:name] %>">
              <%= segment[:name].truncate(20) %>
            </div>
            <div class="timeline-track">
              <div class="timeline-segment" 
                   style="width: <%= ((segment[:duration] / @profile[:duration]) * 100).round(1) %>%; 
                          left: <%= ((segment[:start_time] / @profile[:duration]) * 100).round(1) %>%;
                          background-color: <%= segment_color(segment[:type]) %>;"
                   title="<%= segment[:name] %>: <%= segment[:duration].round(2) %> ms"></div>
            </div>
            <div class="timeline-duration">
              <%= segment[:duration].round(2) %> ms
            </div>
          </div>
        <% end %>
      </div>
    <% end %>
  </div>

  <% if @profile[:queries].present? %>
    <div class="queries-section">
      <div class="section-header">
        <h2>Database Queries</h2>
        <span class="text-muted"><%= @profile[:queries].size %> queries in <%= @profile[:db_time].round(2) %> ms</span>
      </div>
      
      <% @profile[:queries].each_with_index do |query, index| %>
        <div class="query-item">
          <div class="query-header">
            <span class="query-number">#<%= index + 1 %></span>
            <span class="query-duration <%= query[:duration] > 100 ? 'text-danger' : (query[:duration] > 50 ? 'text-warning' : 'text-success') %>">
              <%= query[:duration].round(2) %> ms
            </span>
            <span class="query-name">
              <%= query[:name] || "SQL Query" %>
            </span>
          </div>
          
          <div class="query-sql">
            <code><%= query[:sql] %></code>
          </div>
          
          <% if query[:source].present? %>
            <div class="query-source mt-2">
              <small class="text-muted">Source: <%= query[:source].to_s %></small>
            </div>
          <% end %>
        </div>
      <% end %>
    </div>
  <% end %>
  
  <% if @profile[:code_profiles].present? %>
    <div class="code-profiles-section">
      <div class="section-header">
        <h2>Code Hotspots</h2>
      </div>
      
      <div class="card">
        <div class="card-body">
          <table class="table">
            <thead>
              <tr>
                <th>File</th>
                <th>Line</th>
                <th>Method</th>
                <th>Duration</th>
                <th>% of Total</th>
              </tr>
            </thead>
            <tbody>
              <% @profile[:code_profiles].sort_by { |cp| -cp[:duration] }.each do |profile| %>
                <tr>
                  <td><%= profile[:file].to_s.split('/').last(2).join('/') %></td>
                  <td><%= profile[:line] %></td>
                  <td><code><%= profile[:method] %></code></td>
                  <td>
                    <span class="duration <%= profile[:duration] > 100 ? 'slow' : (profile[:duration] > 50 ? 'medium' : 'fast') %>">
                      <%= profile[:duration].round(2) %> ms
                    </span>
                  </td>
                  <td>
                    <div class="progress" style="height: 6px; width: 100%;">
                      <div class="progress-bar" role="progressbar" 
                          style="width: <%= ((profile[:duration] / @profile[:duration]) * 100).round(1) %>%; 
                                background-color: <%= profile[:duration] > 100 ? 'var(--danger-color)' : (profile[:duration] > 50 ? 'var(--warning-color)' : 'var(--success-color)') %>;"
                          aria-valuenow="<%= ((profile[:duration] / @profile[:duration]) * 100).round(1) %>" 
                          aria-valuemin="0" 
                          aria-valuemax="100"></div>
                    </div>
                    <%= ((profile[:duration] / @profile[:duration]) * 100).round(1) %>%
                  </td>
                </tr>
              <% end %>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  <% end %>

  <% if @profile[:params].present? && !@profile[:params].empty? %>
    <div class="modal" id="paramsModal" tabindex="-1" aria-labelledby="paramsModalLabel" aria-hidden="true">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="paramsModalLabel">Request Parameters</h5>
          <span class="close">&times;</span>
        </div>
        <div class="modal-body">
          <pre class="params-display"><%= JSON.pretty_generate(@profile[:params].as_json) rescue @profile[:params].inspect %></pre>
        </div>
      </div>
    </div>
  <% end %>
</div>

<style>
  .stat-percentage {
    color: var(--gray-color);
    font-size: 0.75rem;
  }
  
  .progress {
    background-color: #f3f4f6;
    border-radius: 0.25rem;
    overflow: hidden;
  }
  
  .params-display {
    background-color: #f9fafb;
    border-radius: 0.375rem;
    padding: 1rem;
    overflow-x: auto;
    font-family: 'SF Mono', SFMono-Regular, ui-monospace, Menlo, Monaco, Consolas, monospace;
    font-size: 0.75rem;
    line-height: 1.5;
    color: #374151;
    max-height: 400px;
  }
  
  .text-muted {
    color: var(--gray-color);
  }
  
  h1 small {
    font-size: 1rem;
    display: block;
    margin-top: 0.25rem;
    font-weight: normal;
  }
  
  .back-link {
    margin-bottom: 1.5rem;
  }
</style>
</file>

<file path="config/routes.rb">
RailsProfiler::Engine.routes.draw do
  root 'dashboard#index'
  get 'profiles', to: 'dashboard#profiles'
  get 'slowest_queries', to: 'dashboard#slowest_queries'
  get 'endpoints', to: 'dashboard#endpoints'
  get 'trends', to: 'dashboard#trends'
  get 'profiles/:id', to: 'dashboard#show', as: 'profile'
end
</file>

<file path="lib/rails_profiler/profiler.rb">
module RailsProfiler
  class Profiler
    attr_reader :request_id, :started_at, :queries, :segments, :url, :method, :path, :format
    attr_accessor :controller, :action, :endpoint_name, :code_profiles

    def initialize(request_id, url: nil, method: nil, path: nil, format: nil)
      @request_id = request_id
      @started_at = Time.current
      @queries = []
      @segments = []
      @events = [] # For timeline generation
      @code_profiles = [] # For code bottleneck tracking
      @url = url
      @method = method
      @path = path
      @format = format
      
      # Track time spent in different parts of the request
      @view_time = 0
      @db_time = 0
      @ruby_time = 0
      @controller_time = 0
      
      # Track hotspots
      @hotspots = {
        controllers: {},
        models: {},
        views: {},
        methods: {}
      }
      
      # Start tracking framework events for timeline
      subscribe_to_events
    end

    def add_query(query_data)
      @queries << query_data
      # Track time spent in database
      @db_time += query_data[:duration] || 0
      
      # Track if this query is associated with a model
      if query_data[:name]&.include?(' Load')
        model_name = query_data[:name].split(' ')[0]
        @hotspots[:models][model_name] ||= { count: 0, total_time: 0 }
        @hotspots[:models][model_name][:count] += 1
        @hotspots[:models][model_name][:total_time] += query_data[:duration] || 0
      end
    end
    
    def add_code_profile(profile_data)
      @code_profiles << profile_data
      
      # Track code hotspots
      if profile_data[:name].include?('Controller')
        controller_name = profile_data[:name].split('#').first
        action_name = profile_data[:method_name]
        
        # Track controller time
        @hotspots[:controllers][controller_name] ||= { 
          actions: {}, 
          total_time: 0 
        }
        
        @hotspots[:controllers][controller_name][:total_time] += profile_data[:duration]
        
        # Track action time
        @hotspots[:controllers][controller_name][:actions][action_name] ||= {
          count: 0,
          total_time: 0
        }
        
        @hotspots[:controllers][controller_name][:actions][action_name][:count] += 1
        @hotspots[:controllers][controller_name][:actions][action_name][:total_time] += profile_data[:duration]
        
        @controller_time += profile_data[:duration]
      else
        # Track general method hotspots
        method_key = profile_data[:name]
        @hotspots[:methods][method_key] ||= { count: 0, total_time: 0, exclusive_time: 0 }
        @hotspots[:methods][method_key][:count] += 1
        @hotspots[:methods][method_key][:total_time] += profile_data[:duration]
        @hotspots[:methods][method_key][:exclusive_time] += profile_data[:exclusive_duration]
      end
    end
    
    def add_event(event_data)
      @events << event_data
      
      # Track view rendering hotspots
      if event_data[:category] == 'view'
        view_name = event_data[:name].to_s.split(' ').last
        @hotspots[:views][view_name] ||= { count: 0, total_time: 0 }
        @hotspots[:views][view_name][:count] += 1
        @hotspots[:views][view_name][:total_time] += event_data[:duration]
      end
    end
    
    # Get child methods for a given method to build call graph
    def child_methods(method_name)
      @code_profiles.select { |p| p[:parent] == method_name }
    end

    def add_controller_info(controller:, action:)
      @controller = controller
      @action = action
      # Normalize endpoint name like Skylight does (Controller#action)
      @endpoint_name = "#{controller.sub(/Controller$/, '')}##{action}"
    end
    
    def process_segments(total_duration)
      # Convert events into timeline segments
      process_events_into_segments
      
      # Calculate ruby time (total time minus db and view time and controller time)
      @ruby_time = total_duration - @db_time - @view_time - @controller_time
      @ruby_time = 0 if @ruby_time < 0 # Ensure we don't have negative time
      
      # Create segment percentages for visualization
      db_percentage = (@db_time / total_duration) * 100 rescue 0
      view_percentage = (@view_time / total_duration) * 100 rescue 0
      controller_percentage = (@controller_time / total_duration) * 100 rescue 0
      ruby_percentage = (@ruby_time / total_duration) * 100 rescue 0
      
      # Add top-level segments for the timeline view
      @segments << { name: "Database", duration: @db_time, percentage: db_percentage, color: "#3498DB" }
      @segments << { name: "View", duration: @view_time, percentage: view_percentage, color: "#2ECC71" }
      @segments << { name: "Controller", duration: @controller_time, percentage: controller_percentage, color: "#E67E22" }
      @segments << { name: "Ruby", duration: @ruby_time, percentage: ruby_percentage, color: "#9B59B6" }
    end

    def finish(status, duration = nil)

      return if status < 100

      total_duration = duration || calculate_duration
      query_count = @queries.size
      total_query_time = @queries.sum { |q| q[:duration] || 0 }
      
      # Build call graph for visualization
      call_graph = build_call_graph
      
      # Get top hotspots for quick access
      top_hotspots = {
        controllers: top_items_from_hash(@hotspots[:controllers], :total_time, 5),
        methods: top_items_from_hash(@hotspots[:methods], :exclusive_time, 10),
        models: top_items_from_hash(@hotspots[:models], :total_time, 5),
        views: top_items_from_hash(@hotspots[:views], :total_time, 5)
      }

      
      
      data = {
        request_id: @request_id,
        url: @url,
        method: @method,
        path: @path,
        controller: @controller,
        action: @action,
        endpoint_name: @endpoint_name,
        format: @format,
        status: status,
        started_at: @started_at,
        duration: total_duration,
        query_count: query_count,
        total_query_time: total_query_time,
        view_time: @view_time,
        db_time: @db_time,
        controller_time: @controller_time,
        ruby_time: @ruby_time,
        queries: @queries,
        segments: @segments,
        additional_data: { 
          events: @events,
          profiles: @code_profiles,
          call_graph: call_graph,
          hotspots: top_hotspots
        }
      }

      Storage.store_profile(data)
    end
    
    def add_code_profile(data)
      method_name = data[:name]
      
      # Create or update the code profile
      if @code_profiles[method_name]
        existing = @code_profiles[method_name]
        existing[:count] += 1
        existing[:total_duration] += data[:duration]
        existing[:max_duration] = [existing[:max_duration], data[:duration]].max
        existing[:min_duration] = [existing[:min_duration], data[:duration]].min
        
        # Track memory if available
        if data[:memory_delta]
          existing[:total_memory_delta] ||= 0
          existing[:total_memory_delta] += data[:memory_delta]
          existing[:max_memory_delta] = [existing[:max_memory_delta] || 0, data[:memory_delta]].max
        end
      else
        @code_profiles[method_name] = {
          name: method_name,
          method_name: data[:method_name],
          method_type: data[:method_type],
          file_path: data[:file_path],
          line_number: data[:line_number],
          count: 1,
          total_duration: data[:duration],
          max_duration: data[:duration],
          min_duration: data[:duration],
          exclusive_duration: data[:exclusive_duration] || data[:duration],
          total_memory_delta: data[:memory_delta],
          max_memory_delta: data[:memory_delta],
          backtrace: data[:backtrace]
        }
      end
      
      # Build call graph
      if data[:parent]
        @call_graph[data[:parent]] ||= {}
        @call_graph[data[:parent]][method_name] ||= 0
        @call_graph[data[:parent]][method_name] += 1
        
        @call_counts[method_name] ||= 0
        @call_counts[method_name] += 1
      end
    end
    
    def add_query_profile(data)
      @query_profiles << data.merge(
        started_at: data[:started_at] || Process.clock_gettime(Process::CLOCK_MONOTONIC)
      )
    end
    
    def prepare_code_profiles
      # Convert code_profiles hash to array and calculate average durations
      @code_profiles.values.map do |profile|
        profile[:avg_duration] = profile[:total_duration] / profile[:count]
        profile[:avg_memory_delta] = profile[:total_memory_delta] / profile[:count] if profile[:total_memory_delta]
        
        # Calculate percentage of total time
        profile[:percent_of_total] = (profile[:total_duration] / @total_duration) * 100
        
        profile
      end
    end
    
    def controller_hotspots
      prepare_code_profiles.select { |p| p[:method_type] == 'controller' }
                            .sort_by { |p| -p[:total_duration] }
    end
    
    def method_hotspots(limit = 10)
      prepare_code_profiles.sort_by { |p| -p[:total_duration] }
                           .first(limit)
    end
    
    def memory_hotspots(limit = 10)
      prepare_code_profiles.select { |p| p[:total_memory_delta] }
                           .sort_by { |p| -p[:total_memory_delta].to_i }
                           .first(limit)
    end
    
    def model_hotspots(limit = 10)
      prepare_code_profiles.select { |p| p[:method_type] == 'model' }
                           .sort_by { |p| -p[:total_duration] }
                           .first(limit)
    end
    
    def view_hotspots(limit = 10)
      prepare_code_profiles.select { |p| p[:method_type] == 'view' }
                           .sort_by { |p| -p[:total_duration] }
                           .first(limit)
    end
    
    def flame_graph_data
      # Generate flame graph data structure
      nodes = {}
      links = []
      
      # Create nodes for each method
      prepare_code_profiles.each do |profile|
        nodes[profile[:name]] = {
          id: profile[:name],
          name: profile[:name],
          value: profile[:total_duration].round(2),
          count: profile[:count],
          type: profile[:method_type]
        }
      end
      
      # Create links between methods
      @call_graph.each do |parent, children|
        children.each do |child, count|
          links << {
            source: parent,
            target: child,
            value: count
          }
        end
      end
      
      { nodes: nodes.values, links: links }
    end
    
    private
    
    def calculate_duration
      (Time.current - @started_at) * 1000 # in milliseconds
    end
    
    def subscribe_to_events
      # Subscribe to ActiveSupport notifications for timeline tracking
      @subscribers = []
      
      # Track view rendering time
      @subscribers << ActiveSupport::Notifications.subscribe("render_template.action_view") do |*args|
        event = ActiveSupport::Notifications::Event.new(*args)
        @view_time += event.duration
        add_event({
          name: "Render #{event.payload[:identifier]&.split('/')&.last}",
          category: "view",
          start: event.time.to_f,
          finish: event.end.to_f,
          duration: event.duration
        })
      end
      
      # Track partial rendering
      @subscribers << ActiveSupport::Notifications.subscribe("render_partial.action_view") do |*args|
        event = ActiveSupport::Notifications::Event.new(*args)
        @view_time += event.duration
        add_event({
          name: "Render partial #{event.payload[:identifier]&.split('/')&.last}",
          category: "view",
          start: event.time.to_f,
          finish: event.end.to_f,
          duration: event.duration
        })
      end
      
      # Track action controller events
      @subscribers << ActiveSupport::Notifications.subscribe("process_action.action_controller") do |*args|
        event = ActiveSupport::Notifications::Event.new(*args)
        add_event({
          name: "Controller action",
          category: "controller",
          start: event.time.to_f,
          finish: event.end.to_f,
          duration: event.duration,
          details: "#{event.payload[:controller]}##{event.payload[:action]}"
        })
      end
    end
    
    def process_events_into_segments
      # Convert raw events into structured segments for visualization
      @events.sort_by { |e| e[:start] }.each do |event|
        case event[:category]
        when "view"
          @segments << {
            name: event[:name],
            duration: event[:duration],
            category: "view",
            color: "#2ECC71"
          }
        when "controller"
          @segments << {
            name: event[:name],
            duration: event[:duration],
            category: "controller", 
            details: event[:details],
            color: "#E67E22"
          }
        end
      end
    end
    
    # Build a call graph for flame graph visualization
    def build_call_graph
      # Create a hierarchical structure of method calls
      root_nodes = @code_profiles.select { |p| p[:parent].nil? }
      
      root_nodes.map do |node|
        build_node(node)
      end
    end
    
    def build_node(profile)
      children = @code_profiles.select { |p| p[:parent] == profile[:name] }
      
      {
        name: profile[:name],
        method_name: profile[:method_name],
        duration: profile[:duration],
        exclusive_duration: profile[:exclusive_duration],
        file_path: profile[:file_path],
        line_number: profile[:line_number],
        children: children.map { |child| build_node(child) }
      }
    end
    
    # Extract top items from a hash based on a specific value key
    def top_items_from_hash(hash, value_key, limit)
      hash.map do |key, data|
        { name: key, value: data[value_key], data: data }
      end.sort_by { |item| -item[:value] }.take(limit)
    end
  end
end
</file>

<file path="lib/rails_profiler/configuration.rb">
module RailsProfiler
  class Configuration
    attr_accessor :enabled, :storage_backend, :redis_url, :sample_rate,
                  :track_queries, :track_code, :retention_days,
                  :dashboard_username, :dashboard_password,
                  :cleanup_interval, :profile_controllers, :profile_models,
                  :auto_profile_methods, :color_scheme

    def initialize
      @enabled = true #Rails.env.production? || Rails.env.staging?
      @storage_backend = :redis
      @redis_url = ENV.fetch('REDIS_URL', 'redis://localhost:6379/12')
      @sample_rate = 0.1 # Sample 10% of requests
      @track_queries = true
      @track_code = true
      @retention_days = 7
      @dashboard_username = ENV.fetch('PROFILER_USERNAME', 'admin')
      @dashboard_password = ENV.fetch('PROFILER_PASSWORD', 'password')
      @cleanup_interval = 1.day # Run cleanup task every day when using database storage
      
      # New options for enhanced method-level profiling
      @profile_controllers = true # Automatically profile all controller actions
      @profile_models = true # Automatically profile model methods 
      @auto_profile_methods = []  # Array of method patterns to auto-profile (e.g. ['User#*', 'Post#save'])
      
      # UI customization
      @color_scheme = {
        primary: "#1E5EFA",       # Skylight blue
        secondary: "#6C47FF",     # Skylight purple
        success: "#2ECC71",       # Green
        warning: "#F1C40F",       # Yellow
        danger: "#E74C3C",        # Red
        info: "#3498DB",          # Blue
        background: "#F5F7FA",    # Light gray background
        card: "#FFFFFF",          # White cards
        text: "#2C3E50",          # Dark text
        muted: "#95A5A6",         # Muted text
        
        # Component-specific colors
        database: "#3498DB",      # Blue for database segments
        view: "#2ECC71",          # Green for view segments
        controller: "#E67E22",    # Orange for controller segments
        ruby: "#9B59B6",          # Purple for Ruby segments
        javascript: "#F1C40F",    # Yellow for JS segments
        api: "#1ABC9C"            # Teal for API segments
      }
    end

    def validate!
      unless [:redis, :database].include?(@storage_backend)
        raise ArgumentError, "Invalid storage_backend: #{@storage_backend}. Valid options are :redis and :database"
      end
    end
  end
end
</file>

<file path="lib/rails_profiler/engine.rb">
require "rails"

module RailsProfiler
  class Engine < ::Rails::Engine
    isolate_namespace RailsProfiler
    
    # Class variable to store the engine's mount path
    cattr_accessor :mount_path
    self.mount_path = nil

    # Insert middleware earlier in the initialization process
    initializer "rails_profiler.insert_middleware", before: :load_config_initializers do |app|
      puts "[RailsProfiler] Engine initializer: Inserting middleware, enabled=#{RailsProfiler.config.enabled}"
      if RailsProfiler.enabled?
        app.middleware.insert_after ActionDispatch::RequestId, RailsProfiler::Middleware
      end
    end

    initializer "rails_profiler.configure" do |app|
      puts "[RailsProfiler] Engine initializer: Configuring with sample_rate=#{RailsProfiler.config.sample_rate}, redis_url=#{RailsProfiler.config.redis_url}"
      
      app.config.after_initialize do
        if RailsProfiler.enabled?
          puts "[RailsProfiler] Engine after_initialize: Profiling is enabled, using #{RailsProfiler.config.storage_backend} backend"
          
          # Test Redis connectivity if Redis backend is configured
          if RailsProfiler.config.storage_backend == :redis
            begin
              puts "[RailsProfiler] Testing Redis connectivity at #{RailsProfiler.config.redis_url}..."
              redis = Redis.new(url: RailsProfiler.config.redis_url)
              test_key = "rails_profiler:test:#{Time.now.to_i}"
              test_value = "Redis connectivity test at #{Time.now}"
              redis.setex(test_key, 60, test_value)
              retrieved = redis.get(test_key)
              puts "[RailsProfiler] ✅ Redis connection successful. Wrote test key: #{test_key}"
              puts "[RailsProfiler] ✅ Redis test: wrote '#{test_value}', retrieved '#{retrieved}'"
            rescue => e
              puts "[RailsProfiler] ❌ Redis connection ERROR: #{e.class.name} - #{e.message}"
              puts e.backtrace.join("\n")
            end
          end
          
          if RailsProfiler.config.track_queries
            RailsProfiler::QueryTracker.install!
          end

          # Set up database cleanup task if using database storage
          if RailsProfiler.config.storage_backend == :database
            setup_database_cleanup
          end
        else
          puts "[RailsProfiler] Engine after_initialize: Profiling is disabled"
        end
      end
    end

    initializer "rails_profiler.assets" do |app|
      puts "[RailsProfiler] Engine initializer: Precompiling assets"
      app.config.assets.precompile += %w[rails_profiler/application.css rails_profiler/application.js]
    end

    private

    def setup_database_cleanup
      if defined?(ActiveSupport::Reloader)
        ActiveSupport::Reloader.to_prepare do
          # Schedule database cleanup if ActiveJob is available
          if defined?(ActiveJob) && defined?(::Rails.application.config.active_job)
            # Could create a scheduled job here if needed
            # For now we'll rely on the rake task
          end
        end
      end
    end
  end
end
</file>

<file path="lib/rails_profiler/middleware.rb">
module RailsProfiler
  class Middleware
    def initialize(app)
      @app = app
      Rails.logger.info "[RailsProfiler] Middleware initialized with config: enabled=#{RailsProfiler.config.enabled}, storage=#{RailsProfiler.config.storage_backend}, sample_rate=#{RailsProfiler.config.sample_rate}"
    end

    def call(env)
      # Create a request object early to check if it's a profiler request
      request = ActionDispatch::Request.new(env)

      unless should_profile?(request)
        return @app.call(env)
      end

      request_id = SecureRandom.uuid
      
      Rails.logger.debug "[RailsProfiler] ✅ Starting profiling for request_id: #{request_id}, path: #{request.path}"

      # Start timing the entire request
      start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      
      # Create profiler with request information
      profiler = Profiler.new(
        request_id,
        url: request.url,
        method: request.method,
        path: request.path,
        format: request.format.to_s
      )
      
      Thread.current[:rails_profiler_current] = profiler

      # Execute the request
      status, headers, response = @app.call(env)
      
      # Calculate total duration
      end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      duration = (end_time - start_time) * 1000 # ms
      
      # Extract controller/action from env
      controller = env['action_controller.instance']
      if controller
        profiler.add_controller_info(
          controller: controller.class.name,
          action: env['action_dispatch.request.path_parameters'][:action]
        )
      end
      
      # Add segments data based on instrumentation results
      profiler.process_segments(duration)
      
      if status < 100 
        Rails.logger.error "[RailsProfiler] ❌ Invalid status code: #{status} for request_id: #{request_id}"
        return [status, headers, response]
      end

      # Finish profiling and store the data
      profiler.finish(status, duration)

      [status, headers, response]
    ensure
      Thread.current[:rails_profiler_current] = nil
    end

    private

    def should_profile?(request)
      enabled = RailsProfiler.config.enabled
      sample_rate = RailsProfiler.config.sample_rate
      sample = rand < sample_rate
      
      # Get the mount path from the engine
      mount_path = RailsProfiler.engine_mount_path
      
      # Check if this is a request to the profiler engine itself
      # Handle both exact matches and sub-paths
      is_profiler_request = request.path == mount_path || 
                            (mount_path != '/' && request.path.start_with?(mount_path))
      
      if is_profiler_request
        return false
      end
      
      # Skip asset requests
      is_asset_request = request.path.start_with?('/assets/', '/packs/', '/images/', '/javascripts/', '/stylesheets/')
      
      enabled && sample && !is_profiler_request && !is_asset_request
    end
  end
end
</file>

<file path="lib/rails_profiler/storage.rb">
require "redis"
require "json"

module RailsProfiler
  class Storage
    def self.store_profile(data)
      puts "[RailsProfiler] Storage.store_profile called with backend: #{RailsProfiler.config.storage_backend}"
      
      case RailsProfiler.config.storage_backend
      when :redis
        RedisStorage.store_profile(data)
      when :database
        DatabaseStorage.store_profile(data)
      end
    end

    def self.get_profiles(limit: 100, offset: 0)
      case RailsProfiler.config.storage_backend
      when :redis
        RedisStorage.get_profiles(limit: limit, offset: offset)
      when :database
        DatabaseStorage.get_profiles(limit: limit, offset: offset)
      end
    end

    def self.get_profile(request_id)
      case RailsProfiler.config.storage_backend
      when :redis
        RedisStorage.get_profile(request_id)
      when :database
        DatabaseStorage.get_profile(request_id)
      end
    end

    def self.get_summary_stats
      case RailsProfiler.config.storage_backend
      when :redis
        RedisStorage.get_summary_stats
      when :database
        DatabaseStorage.get_summary_stats
      end
    end
  end

  class RedisStorage
    def self.redis
      @redis ||= begin
        url = RailsProfiler.config.redis_url
        puts "[RailsProfiler] Redis: Connecting to Redis at: #{url}"
        begin
          client = Redis.new(url: url)
          # Test the connection
          client.ping
          puts "[RailsProfiler] Redis: Successfully connected to Redis"
          client
        rescue => e
          puts "[RailsProfiler] Redis: Connection error: #{e.class.name} - #{e.message}"
          puts e.backtrace.join("\n")
          raise
        end
      end
    end

    def self.store_profile(data)
      # Skip profiles with status < 100 (WebSocket connections like /cable or /hotwire-spark)
      return if data[:status].to_i < 100
      
      key = "rails_profiler:profile:#{data[:request_id]}"
      begin
        puts "[RailsProfiler] Redis: Storing profile with key: #{key}"
        redis.setex(key, retention_seconds, data.to_json)
        puts "[RailsProfiler] Redis: Adding to sorted set rails_profiler:profiles with request_id: #{data[:request_id]}"
        redis.zadd("rails_profiler:profiles", data[:started_at].to_f, data[:request_id])
        puts "[RailsProfiler] Redis: Successfully stored profile with key: #{key}"
      rescue => e
        puts "[RailsProfiler] Redis error storing profile: #{e.class.name} - #{e.message}"
        puts e.backtrace.join("\n")
        Rails.logger.error "[RailsProfiler] Redis error storing profile: #{e.class.name} - #{e.message}"
        Rails.logger.error e.backtrace.join("\n")
      end
    end

    def self.get_profiles(limit: 100, offset: 0)
      request_ids = redis.zrevrange("rails_profiler:profiles", offset, offset + limit - 1)
      profiles = request_ids.map { |id| get_profile(id) }.compact
      
      # Filter out any profiles with status < 100 (WebSocket connections like /cable or /hotwire-spark)
      # This ensures old entries don't appear in the dashboard
      profiles = profiles.reject { |p| p[:status].to_i < 100 }
      
      profiles
    end

    def self.get_profile(request_id)
      key = "rails_profiler:profile:#{request_id}"
      data = redis.get(key)
      data ? JSON.parse(data, symbolize_names: true) : nil
    end

    def self.get_summary_stats
      total_profiles = redis.zcard("rails_profiler:profiles")
      latest_profiles = get_profiles(limit: 100)
      
      return {} if latest_profiles.empty?

      avg_duration = latest_profiles.sum { |p| p[:duration] } / latest_profiles.size
      avg_queries = latest_profiles.sum { |p| p[:query_count] } / latest_profiles.size
      avg_query_time = latest_profiles.sum { |p| p[:total_query_time] } / latest_profiles.size

      {
        total_profiles: latest_profiles.size, # Use filtered count instead of raw Redis count
        avg_duration: avg_duration,
        avg_queries: avg_queries,
        avg_query_time: avg_query_time,
        latest_profiles: latest_profiles.first(20)
      }
    end

    private

    def self.retention_seconds
      days = RailsProfiler.config.retention_days
      seconds = days * 24 * 60 * 60
      puts "[RailsProfiler] Redis: Using retention period of #{days} days (#{seconds} seconds)"
      seconds
    end
  end

  class DatabaseStorage
    def self.store_profile(data)
      # Skip profiles with status < 100 (WebSocket connections like /cable or /hotwire-spark)
      return if data[:status].to_i < 100
      
      # Convert data hash to a format suitable for database storage
      profile_data = {
        request_id: data[:request_id],
        url: data[:url],
        method: data[:method],
        path: data[:path],
        controller: data[:controller],
        action: data[:action],
        endpoint_name: data[:endpoint_name],
        format: data[:format],
        status: data[:status],
        duration: data[:duration],
        query_count: data[:query_count],
        total_query_time: data[:total_query_time],
        view_time: data[:view_time],
        db_time: data[:db_time],
        ruby_time: data[:ruby_time],
        started_at: data[:started_at],
        queries: data[:queries].to_json,
        segments: data[:segments].to_json,
        additional_data: data[:additional_data].to_json
      }

      # Find existing record or create new one
      profile = Profile.find_or_initialize_by(request_id: data[:request_id])
      profile.update!(profile_data)
    end

    def self.get_profiles(limit: 100, offset: 0)
      Profile.where("status >= 100")
             .order(started_at: :desc)
             .limit(limit)
             .offset(offset)
             .map do |profile|
        # Convert database record back to the format expected by the application
        {
          request_id: profile.request_id,
          url: profile.url,
          method: profile.method,
          path: profile.path,
          controller: profile.controller,
          action: profile.action,
          endpoint_name: profile.endpoint_name,
          format: profile.format,
          status: profile.status,
          duration: profile.duration,
          query_count: profile.query_count,
          total_query_time: profile.total_query_time,
          view_time: profile.view_time,
          db_time: profile.db_time,
          ruby_time: profile.ruby_time,
          started_at: profile.started_at,
          queries: JSON.parse(profile.queries, symbolize_names: true),
          segments: JSON.parse(profile.segments, symbolize_names: true),
          additional_data: JSON.parse(profile.additional_data, symbolize_names: true)
        }
      end
    end

    def self.get_profile(request_id)
      profile = Profile.find_by(request_id: request_id)
      return nil unless profile

      # Convert database record to the format expected by the application
      {
        request_id: profile.request_id,
        url: profile.url,
        method: profile.method,
        path: profile.path,
        controller: profile.controller,
        action: profile.action,
        endpoint_name: profile.endpoint_name,
        format: profile.format,
        status: profile.status,
        duration: profile.duration,
        query_count: profile.query_count,
        total_query_time: profile.total_query_time,
        view_time: profile.view_time,
        db_time: profile.db_time,
        ruby_time: profile.ruby_time,
        started_at: profile.started_at,
        queries: JSON.parse(profile.queries, symbolize_names: true),
        segments: JSON.parse(profile.segments, symbolize_names: true),
        additional_data: JSON.parse(profile.additional_data, symbolize_names: true)
      }
    end

    def self.get_summary_stats
      # Use filtered count for consistency with Redis implementation
      total_profiles = Profile.where("status >= 100").count
      latest_profiles = get_profiles(limit: 50)
      
      return {} if latest_profiles.empty?
      
      # Aggregate endpoints like Skylight does
      endpoints = aggregate_endpoints

      # Calculate averages based on filtered profiles
      avg_duration = Profile.where("status >= 100").average(:duration).to_f
      avg_queries = Profile.where("status >= 100").average(:query_count).to_f
      avg_query_time = Profile.where("status >= 100").average(:total_query_time).to_f

      {
        total_profiles: total_profiles,
        avg_duration: avg_duration,
        avg_queries: avg_queries,
        avg_query_time: avg_query_time,
        endpoints: endpoints,
        latest_profiles: latest_profiles
      }
    end
    
    # Similar to Skylight's endpoint aggregation
    def self.aggregate_endpoints
      # Group by endpoint_name and get performance metrics, filtering out status < 100
      endpoint_stats = Profile.where.not(endpoint_name: nil)
                              .where("status >= 100")
                              .group(:endpoint_name)
                              .select(
                                "endpoint_name, 
                                COUNT(*) as request_count, 
                                AVG(duration) as avg_duration, 
                                MAX(duration) as max_duration,
                                AVG(db_time) as avg_db_time,
                                AVG(view_time) as avg_view_time,
                                AVG(ruby_time) as avg_ruby_time"
                              )
                              
      # Convert to the format needed for the UI
      endpoints = endpoint_stats.map do |stat|
        {
          name: stat.endpoint_name,
          count: stat.request_count,
          avg_duration: stat.avg_duration,
          max_duration: stat.max_duration,
          avg_db_time: stat.avg_db_time,
          avg_view_time: stat.avg_view_time,
          avg_ruby_time: stat.avg_ruby_time,
          # Calculate percentages for the segments visualization
          segments: [
            { name: "Database", percentage: (stat.avg_db_time / stat.avg_duration) * 100, color: "blue" },
            { name: "View", percentage: (stat.avg_view_time / stat.avg_duration) * 100, color: "green" },
            { name: "Ruby", percentage: (stat.avg_ruby_time / stat.avg_duration) * 100, color: "purple" }
          ]
        }
      end
      
      # Sort by average duration (slowest first)
      endpoints.sort_by { |e| -e[:avg_duration] }
    end
    
    # Get time-series data for trend charts
    def self.get_trends(days: 7)
      start_date = days.days.ago.beginning_of_day
      
      # Group by hour and count requests
      hourly_counts = Profile.where("started_at >= ?", start_date)
                            .group("date_trunc('hour', started_at)")
                            .count
                            
      # Calculate average durations by hour
      hourly_durations = Profile.where("started_at >= ?", start_date)
                               .group("date_trunc('hour', started_at)")
                               .average(:duration)
                               
      # Merge into a single dataset for charting
      hourly_data = []
      
      # Combine counts and durations
      (start_date.to_i..Time.current.to_i).step(1.hour) do |timestamp|
        datetime = Time.at(timestamp)
        hour_key = datetime.utc.change(min: 0, sec: 0)
        
        hourly_data << {
          timestamp: datetime.to_i * 1000, # Convert to milliseconds for JS charts
          count: hourly_counts[hour_key] || 0,
          avg_duration: hourly_durations[hour_key] || 0
        }
      end
      
      hourly_data
    end
    
    # Helper method to clean up old profiles based on retention days
    # Returns the number of deleted profiles
    def self.cleanup_old_profiles
      retention_date = RailsProfiler.config.retention_days.days.ago
      Profile.where('started_at < ?', retention_date).delete_all
    end
  end
end
</file>

<file path="lib/rails_profiler.rb">
require "rails_profiler/version"
require "rails_profiler/configuration"
require "rails_profiler/engine"
require "rails_profiler/middleware"
require "rails_profiler/profiler"
require "rails_profiler/query_tracker"
require "rails_profiler/code_profiler"
require "rails_profiler/storage"

# Add detection of mount path
module ActionDispatch
  module Routing
    class Mapper
      # Store original mount method
      alias_method :original_mount, :mount

      # Override mount method to detect Rails Profiler mounting
      def mount(app, options = nil)
        if app == RailsProfiler::Engine
          path = options[:at] || '/'
          RailsProfiler::Engine.mount_path = path
          puts "[RailsProfiler] Detected engine mount at: #{path}"
        end
        original_mount(app, options)
      end
    end
  end
end

module RailsProfiler
  class << self
    def configure
      @config ||= Configuration.new
      yield(@config)
      @config.validate!
      puts "[RailsProfiler] Configured with storage_backend=#{@config.storage_backend}, enabled=#{@config.enabled}, sample_rate=#{@config.sample_rate}, redis_url=#{@config.redis_url}"
      Rails.logger.info "[RailsProfiler] Configured with storage_backend=#{@config.storage_backend}, enabled=#{@config.enabled}, sample_rate=#{@config.sample_rate}, redis_url=#{@config.redis_url}"
    end

    def config
      @config ||= Configuration.new
    end

    def enabled?
      config.enabled
    end

    def profile(name = nil, &block)
      return yield unless enabled? && config.track_code

      name ||= caller_location_name
      start_time = Time.current

      begin
        yield
      ensure
        duration = (Time.current - start_time) * 1000 # in milliseconds

        if current_profiler
          Rails.logger.debug "[RailsProfiler] Adding code profile: #{name}, duration: #{duration}ms"
          current_profiler.add_profile(name: name, duration: duration)
        else
          Rails.logger.debug "[RailsProfiler] No active profiler for code profile: #{name}"
        end
      end
    end

    def current_profiler
      Thread.current[:rails_profiler_current]
    end

    def engine_mount_path
      RailsProfiler::Engine.mount_path || '/profiler'
    end

    private

    def caller_location_name
      location = caller_locations(2, 1).first
      "#{location.path}:#{location.lineno}"
    end
  end
end
</file>

</files>
