<div class="page-header">
  <h1 class="page-title">Flame Graph</h1>
  <div class="page-actions">
    <div class="dropdown">
      <button class="btn btn-secondary dropdown-toggle">
        <%= @profile ? "#{@profile[:controller]}##{@profile[:action]}" : "Select Profile" %>
        <i class="fas fa-chevron-down ml-1"></i>
      </button>
      <div class="dropdown-menu">
        <% if @available_profiles.present? %>
          <% @available_profiles.each do |profile| %>
            <a href="<%= flame_graph_path(profile_id: profile[:request_id]) %>" class="dropdown-item">
              <%= profile[:controller] %>#<%= profile[:action] %> (<%= profile[:request_id][0..7] %>)
            </a>
          <% end %>
        <% else %>
          <span class="dropdown-item disabled">No profiles available</span>
        <% end %>
      </div>
    </div>
  </div>
</div>

<% if @flame_data.blank? %>
  <div class="alert alert-info">
    <i class="fas fa-info-circle mr-2"></i>
    No code profiling data is available. Make sure you have enabled code profiling with <code>config.track_code = true</code>.
  </div>
<% else %>
  <div class="card mb-4">
    <div class="card-header">
      <div class="card-title">
        Flame Graph for <%= @profile[:controller] %>#<%= @profile[:action] %>
      </div>
      <div class="card-description">
        <span class="text-muted">
          Request ID: <%= @profile[:request_id] %>, Duration: <%= @profile[:duration].round(2) %> ms
        </span>
      </div>
    </div>
    <div class="card-body">
      <div class="flame-graph-container" id="flame-graph"></div>
      <div class="flame-graph-controls mt-2">
        <button class="btn btn-sm btn-outline-primary" id="resetFlameGraph">Reset Zoom</button>
        <button class="btn btn-sm btn-outline-secondary" id="searchFlameGraph">Search</button>
      </div>
      <div class="legend mt-2">
        <span class="badge method-type-controller mr-2">Controller</span>
        <span class="badge method-type-model mr-2">Model</span>
        <span class="badge method-type-view mr-2">View</span>
        <span class="badge method-type-ruby mr-2">Ruby</span>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="card-header">
      <div class="card-title">Method Execution Times</div>
      <div class="card-actions">
        <div class="search-container">
          <input type="text" id="method-search" class="form-control form-control-sm" placeholder="Search methods...">
        </div>
      </div>
    </div>
    <div class="card-body p-0">
      <div class="table-responsive">
        <table class="table table-hover table-striped method-table">
          <thead>
            <tr>
              <th>Method</th>
              <th>Type</th>
              <th>Calls</th>
              <th>Total Time (ms)</th>
              <th>Avg Time (ms)</th>
              <th>% of Request</th>
            </tr>
          </thead>
          <tbody>
            <% @flame_data.each do |method_data| %>
              <tr class="method-row" data-method-name="<%= method_data[:name] %>">
                <td class="method-name" title="<%= method_data[:name] %>">
                  <%= method_data[:name].truncate(50) %>
                </td>
                <td>
                  <span class="method-type-label method-type-<%= method_data[:method_type] %>">
                    <%= method_data[:method_type] %>
                  </span>
                </td>
                <td><%= method_data[:count] %></td>
                <td><%= method_data[:value].round(2) %> ms</td>
                <td><%= (method_data[:value] / method_data[:count]).round(2) %> ms</td>
                <td>
                  <div class="progress">
                    <div class="progress-bar bg-<%= method_data[:method_type] == 'controller' ? 'warning' : (method_data[:method_type] == 'model' ? 'info' : (method_data[:method_type] == 'view' ? 'danger' : 'primary')) %>"
                         style="width: <%= [(method_data[:value] / @profile[:duration] * 100), 100].min %>%">
                      <%= ((method_data[:value] / @profile[:duration]) * 100).round(1) %>%
                    </div>
                  </div>
                </td>
              </tr>
            <% end %>
          </tbody>
        </table>
      </div>
    </div>
  </div>
<% end %>

<% content_for :scripts do %>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Profile dropdown functionality
    const dropdownToggle = document.querySelector('.dropdown-toggle');
    const dropdownMenu = document.querySelector('.dropdown-menu');
    
    if (dropdownToggle && dropdownMenu) {
      dropdownToggle.addEventListener('click', function(e) {
        e.preventDefault();
        dropdownMenu.classList.toggle('show');
      });
      
      // Close dropdown when clicking outside
      document.addEventListener('click', function(e) {
        if (!e.target.matches('.dropdown-toggle') && !e.target.closest('.dropdown-toggle')) {
          dropdownMenu.classList.remove('show');
        }
      });
    }
    
    // Method search functionality
    const methodSearch = document.getElementById('method-search');
    if (methodSearch) {
      methodSearch.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const methodRows = document.querySelectorAll('tr.method-row');
        
        methodRows.forEach(function(row) {
          const methodName = row.getAttribute('data-method-name').toLowerCase();
          if (methodName.includes(searchTerm)) {
            row.style.display = '';
          } else {
            row.style.display = 'none';
          }
        });
      });
    }
    
    // Flame graph visualization
    const flameGraphContainer = document.getElementById('flame-graph');
    if (flameGraphContainer && <%= @flame_data.present? ? 'true' : 'false' %>) {
      console.log("Initializing flame graph visualization");
      
      try {
        const flameData = <%= raw @flame_data.to_json %>;
        console.log("Flame data loaded, entries:", flameData.length);
        
        // Check if flame data is empty
        if (!flameData || flameData.length === 0) {
          console.error("No flame data available to visualize");
          flameGraphContainer.innerHTML = '<div class="alert alert-warning">No method data available to visualize for this profile.</div>';
          return;
        }
        
        // Transform the flat data into a hierarchical structure for the flame graph
        const rootNode = {
          name: "root",
          value: 0,
          children: []
        };
        
        // Create a lookup map for method types
        const methodTypes = {};
        flameData.forEach(method => {
          methodTypes[method.name] = method.method_type || 'ruby';
        });
        
        // Sort methods by value (descending) to get the most expensive methods first
        console.log("Sorting methods by execution time");
        const sortedMethods = [...flameData].sort((a, b) => b.value - a.value);
        
        // For each method, create a node in the hierarchy
        console.log("Building hierarchical structure");
        sortedMethods.forEach(method => {
          // Skip methods with very small durations
          if (method.value < 0.1) return;
          
          // Create a path based on method name (splitting by periods, colons, etc)
          let parts = method.name.split(/[\.#:]/);
          
          // If method name doesn't have parts, use it directly
          if (parts.length <= 1) {
            parts = [method.method_type || 'ruby', method.name];
          }
          
          // Begin at the root
          let currentNode = rootNode;
          
          // Traverse/build the path
          for (let i = 0; i < parts.length; i++) {
            let part = parts[i];
            if (!part) part = '(anonymous)';
            
            // For the last part, use the method's value
            if (i === parts.length - 1) {
              const newNode = {
                name: part,
                value: method.value,
                count: method.count,
                methodType: method.method_type || 'ruby',
                fullName: method.name
              };
              
              currentNode.children = currentNode.children || [];
              currentNode.children.push(newNode);
              
              // Add to parent's value for proper sizing
              if (i > 0) {
                currentNode.value = (currentNode.value || 0) + method.value;
              }
            } else {
              // For intermediate parts, find or create a node
              let found = false;
              if (currentNode.children) {
                for (const child of currentNode.children) {
                  if (child.name === part) {
                    currentNode = child;
                    found = true;
                    break;
                  }
                }
              } else {
                currentNode.children = [];
              }
              
              if (!found) {
                const newNode = {
                  name: part,
                  children: [],
                  methodType: methodTypes[part] || 'ruby'
                };
                currentNode.children.push(newNode);
                currentNode = newNode;
              }
            }
          }
        });
        
        console.log("Root node with children created:", rootNode);
        
        // Create color map based on method types
        const colorMap = {
          controller: '#f59e0b', // Amber
          model: '#0ea5e9',      // Sky Blue
          view: '#ec4899',       // Pink
          ruby: '#8b5cf6'        // Purple
        };
        
        // Check that d3.flamegraph is available
        if (typeof d3.flamegraph !== 'function') {
          console.error("d3.flamegraph is not available. Make sure d3-flame-graph library is loaded correctly.");
          flameGraphContainer.innerHTML = '<div class="alert alert-danger">Error: Flame graph library not loaded correctly.</div>';
          return;
        }
        
        try {
          // Create the flame graph
          console.log("Creating flame graph object");
          const flamegraph = d3.flamegraph()
            .width(flameGraphContainer.clientWidth)
            .height(350)
            .tooltip(true)
            .sort(true)
            .title('')
            .differential(false)
            .inverted(false)
            .selfValue(false)
            .color((d) => colorMap[d.data.methodType] || colorMap.ruby);
          
          // Create flame graph SVG
          console.log("Creating SVG element");
          const svg = d3.select('#flame-graph')
            .append('svg')
            .attr('width', '100%')
            .attr('height', '100%');
            
          console.log("Rendering flame graph");
          // Render flame graph with the hierarchical data
          svg.datum(rootNode).call(flamegraph);
          console.log("Flame graph rendered successfully");
          
          // Add reset zoom button functionality
          document.getElementById('resetFlameGraph').addEventListener('click', function() {
            flamegraph.resetZoom();
          });
          
          // Add search functionality
          document.getElementById('searchFlameGraph').addEventListener('click', function() {
            const term = prompt('Enter method name to search:');
            if (term) {
              flamegraph.search(term);
            }
          });
          
          // Highlight methods in flame graph when hovering over table rows
          const methodRows = document.querySelectorAll('tr.method-row');
          methodRows.forEach(function(row) {
            row.addEventListener('mouseenter', function() {
              const methodName = this.getAttribute('data-method-name');
              flamegraph.search(methodName);
            });
            
            row.addEventListener('mouseleave', function() {
              flamegraph.clear();
            });
          });
        } catch (e) {
          console.error("Error rendering flame graph:", e);
          flameGraphContainer.innerHTML = '<div class="alert alert-danger">Error rendering flame graph: ' + e.message + '</div>';
        }
      } catch (e) {
        console.error("Error initializing flame graph:", e);
        flameGraphContainer.innerHTML = '<div class="alert alert-danger">Error initializing flame graph: ' + e.message + '</div>';
      }
    } else if (flameGraphContainer) {
      console.error("Flame graph container exists but no flame data available");
      flameGraphContainer.innerHTML = '<div class="alert alert-warning">No flame data available for visualization.</div>';
    }
  });
</script>
<% end %>